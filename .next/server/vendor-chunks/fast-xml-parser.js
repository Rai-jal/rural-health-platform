"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-xml-parser";
exports.ids = ["vendor-chunks/fast-xml-parser"];
exports.modules = {

/***/ "(rsc)/./node_modules/fast-xml-parser/src/ignoreAttributes.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/ignoreAttributes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getIgnoreAttributesFn)\n/* harmony export */ });\nfunction getIgnoreAttributesFn(ignoreAttributes) {\n    if (typeof ignoreAttributes === \"function\") {\n        return ignoreAttributes;\n    }\n    if (Array.isArray(ignoreAttributes)) {\n        return (attrName)=>{\n            for (const pattern of ignoreAttributes){\n                if (typeof pattern === \"string\" && attrName === pattern) {\n                    return true;\n                }\n                if (pattern instanceof RegExp && pattern.test(attrName)) {\n                    return true;\n                }\n            }\n        };\n    }\n    return ()=>false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy9pZ25vcmVBdHRyaWJ1dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxTQUFTQSxzQkFBc0JDLGdCQUFnQjtJQUMxRCxJQUFJLE9BQU9BLHFCQUFxQixZQUFZO1FBQ3hDLE9BQU9BO0lBQ1g7SUFDQSxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLG1CQUFtQjtRQUNqQyxPQUFPLENBQUNHO1lBQ0osS0FBSyxNQUFNQyxXQUFXSixpQkFBa0I7Z0JBQ3BDLElBQUksT0FBT0ksWUFBWSxZQUFZRCxhQUFhQyxTQUFTO29CQUNyRCxPQUFPO2dCQUNYO2dCQUNBLElBQUlBLG1CQUFtQkMsVUFBVUQsUUFBUUUsSUFBSSxDQUFDSCxXQUFXO29CQUNyRCxPQUFPO2dCQUNYO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBTyxJQUFNO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnVyYWwtaGVhbHRoLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvaWdub3JlQXR0cmlidXRlcy5qcz9lOGRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldElnbm9yZUF0dHJpYnV0ZXNGbihpZ25vcmVBdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBpZ25vcmVBdHRyaWJ1dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVBdHRyaWJ1dGVzXG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlnbm9yZUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJldHVybiAoYXR0ck5hbWUpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBpZ25vcmVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyAmJiBhdHRyTmFtZSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBwYXR0ZXJuLnRlc3QoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBmYWxzZVxufSJdLCJuYW1lcyI6WyJnZXRJZ25vcmVBdHRyaWJ1dGVzRm4iLCJpZ25vcmVBdHRyaWJ1dGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXR0ck5hbWUiLCJwYXR0ZXJuIiwiUmVnRXhwIiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/ignoreAttributes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllMatches: () => (/* binding */ getAllMatches),\n/* harmony export */   getValue: () => (/* binding */ getValue),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExist: () => (/* binding */ isExist),\n/* harmony export */   isName: () => (/* binding */ isName),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   nameRegexp: () => (/* binding */ nameRegexp)\n/* harmony export */ });\n\nconst nameStartChar = \":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\nconst nameChar = nameStartChar + \"\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\nconst nameRegexp = \"[\" + nameStartChar + \"][\" + nameChar + \"]*\";\nconst regexName = new RegExp(\"^\" + nameRegexp + \"$\");\nfunction getAllMatches(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while(match){\n        const allmatches = [];\n        allmatches.startIndex = regex.lastIndex - match[0].length;\n        const len = match.length;\n        for(let index = 0; index < len; index++){\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n}\nconst isName = function(string) {\n    const match = regexName.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\nfunction isExist(v) {\n    return typeof v !== \"undefined\";\n}\nfunction isEmptyObject(obj) {\n    return Object.keys(obj).length === 0;\n}\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */ function merge(target, a, arrayMode) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            if (arrayMode === \"strict\") {\n                target[keys[i]] = [\n                    a[keys[i]]\n                ];\n            } else {\n                target[keys[i]] = a[keys[i]];\n            }\n        }\n    }\n}\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */ function getValue(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n} // const fakeCall = function(a) {return a;};\n // const fakeCallNoReturn = function() {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUVBLE1BQU1BLGdCQUFnQjtBQUN0QixNQUFNQyxXQUFXRCxnQkFBZ0I7QUFDMUIsTUFBTUUsYUFBYSxNQUFNRixnQkFBZ0IsT0FBT0MsV0FBVyxLQUFLO0FBQ3ZFLE1BQU1FLFlBQVksSUFBSUMsT0FBTyxNQUFNRixhQUFhO0FBRXpDLFNBQVNHLGNBQWNDLE1BQU0sRUFBRUMsS0FBSztJQUN6QyxNQUFNQyxVQUFVLEVBQUU7SUFDbEIsSUFBSUMsUUFBUUYsTUFBTUcsSUFBSSxDQUFDSjtJQUN2QixNQUFPRyxNQUFPO1FBQ1osTUFBTUUsYUFBYSxFQUFFO1FBQ3JCQSxXQUFXQyxVQUFVLEdBQUdMLE1BQU1NLFNBQVMsR0FBR0osS0FBSyxDQUFDLEVBQUUsQ0FBQ0ssTUFBTTtRQUN6RCxNQUFNQyxNQUFNTixNQUFNSyxNQUFNO1FBQ3hCLElBQUssSUFBSUUsUUFBUSxHQUFHQSxRQUFRRCxLQUFLQyxRQUFTO1lBQ3hDTCxXQUFXTSxJQUFJLENBQUNSLEtBQUssQ0FBQ08sTUFBTTtRQUM5QjtRQUNBUixRQUFRUyxJQUFJLENBQUNOO1FBQ2JGLFFBQVFGLE1BQU1HLElBQUksQ0FBQ0o7SUFDckI7SUFDQSxPQUFPRTtBQUNUO0FBRU8sTUFBTVUsU0FBUyxTQUFTWixNQUFNO0lBQ25DLE1BQU1HLFFBQVFOLFVBQVVPLElBQUksQ0FBQ0o7SUFDN0IsT0FBTyxDQUFFRyxDQUFBQSxVQUFVLFFBQVEsT0FBT0EsVUFBVSxXQUFVO0FBQ3hELEVBQUM7QUFFTSxTQUFTVSxRQUFRQyxDQUFDO0lBQ3ZCLE9BQU8sT0FBT0EsTUFBTTtBQUN0QjtBQUVPLFNBQVNDLGNBQWNDLEdBQUc7SUFDL0IsT0FBT0MsT0FBT0MsSUFBSSxDQUFDRixLQUFLUixNQUFNLEtBQUs7QUFDckM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU1csTUFBTUMsTUFBTSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDeEMsSUFBSUQsR0FBRztRQUNMLE1BQU1ILE9BQU9ELE9BQU9DLElBQUksQ0FBQ0csSUFBSSx5Q0FBeUM7UUFDdEUsTUFBTVosTUFBTVMsS0FBS1YsTUFBTSxFQUFFLHNCQUFzQjtRQUMvQyxJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSWQsS0FBS2MsSUFBSztZQUM1QixJQUFJRCxjQUFjLFVBQVU7Z0JBQzFCRixNQUFNLENBQUNGLElBQUksQ0FBQ0ssRUFBRSxDQUFDLEdBQUc7b0JBQUVGLENBQUMsQ0FBQ0gsSUFBSSxDQUFDSyxFQUFFLENBQUM7aUJBQUU7WUFDbEMsT0FBTztnQkFDTEgsTUFBTSxDQUFDRixJQUFJLENBQUNLLEVBQUUsQ0FBQyxHQUFHRixDQUFDLENBQUNILElBQUksQ0FBQ0ssRUFBRSxDQUFDO1lBQzlCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0E7O0VBRUUsR0FFSyxTQUFTQyxTQUFTVixDQUFDO0lBQ3hCLElBQUlXLFFBQVFaLE9BQU8sQ0FBQ0MsSUFBSTtRQUN0QixPQUFPQTtJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRixFQUVBLDRDQUE0QztDQUM1QywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydXJhbC1oZWFsdGgtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy91dGlsLmpzPzljZTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuYW1lU3RhcnRDaGFyID0gJzpBLVphLXpfXFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuY29uc3QgbmFtZUNoYXIgPSBuYW1lU3RhcnRDaGFyICsgJ1xcXFwtLlxcXFxkXFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnO1xuZXhwb3J0IGNvbnN0IG5hbWVSZWdleHAgPSAnWycgKyBuYW1lU3RhcnRDaGFyICsgJ11bJyArIG5hbWVDaGFyICsgJ10qJztcbmNvbnN0IHJlZ2V4TmFtZSA9IG5ldyBSZWdFeHAoJ14nICsgbmFtZVJlZ2V4cCArICckJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxNYXRjaGVzKHN0cmluZywgcmVnZXgpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICBsZXQgbWF0Y2ggPSByZWdleC5leGVjKHN0cmluZyk7XG4gIHdoaWxlIChtYXRjaCkge1xuICAgIGNvbnN0IGFsbG1hdGNoZXMgPSBbXTtcbiAgICBhbGxtYXRjaGVzLnN0YXJ0SW5kZXggPSByZWdleC5sYXN0SW5kZXggLSBtYXRjaFswXS5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gbWF0Y2gubGVuZ3RoO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgIGFsbG1hdGNoZXMucHVzaChtYXRjaFtpbmRleF0pO1xuICAgIH1cbiAgICBtYXRjaGVzLnB1c2goYWxsbWF0Y2hlcyk7XG4gICAgbWF0Y2ggPSByZWdleC5leGVjKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmV4cG9ydCBjb25zdCBpc05hbWUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgY29uc3QgbWF0Y2ggPSByZWdleE5hbWUuZXhlYyhzdHJpbmcpO1xuICByZXR1cm4gIShtYXRjaCA9PT0gbnVsbCB8fCB0eXBlb2YgbWF0Y2ggPT09ICd1bmRlZmluZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXhpc3Qodikge1xuICByZXR1cm4gdHlwZW9mIHYgIT09ICd1bmRlZmluZWQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4vKipcbiAqIENvcHkgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIGEgaW50byBiLlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBhLCBhcnJheU1vZGUpIHtcbiAgaWYgKGEpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYSk7IC8vIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIG93biBwcm9wZXJ0aWVzXG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7IC8vZG9uJ3QgbWFrZSBpdCBpbmxpbmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlNb2RlID09PSAnc3RyaWN0Jykge1xuICAgICAgICB0YXJnZXRba2V5c1tpXV0gPSBbIGFba2V5c1tpXV0gXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXlzW2ldXSA9IGFba2V5c1tpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKiBleHBvcnRzLm1lcmdlID1mdW5jdGlvbiAoYixhKXtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYixhKTtcbn0gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlKHYpIHtcbiAgaWYgKGV4cG9ydHMuaXNFeGlzdCh2KSkge1xuICAgIHJldHVybiB2O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vLyBjb25zdCBmYWtlQ2FsbCA9IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYTt9O1xuLy8gY29uc3QgZmFrZUNhbGxOb1JldHVybiA9IGZ1bmN0aW9uKCkge307Il0sIm5hbWVzIjpbIm5hbWVTdGFydENoYXIiLCJuYW1lQ2hhciIsIm5hbWVSZWdleHAiLCJyZWdleE5hbWUiLCJSZWdFeHAiLCJnZXRBbGxNYXRjaGVzIiwic3RyaW5nIiwicmVnZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJleGVjIiwiYWxsbWF0Y2hlcyIsInN0YXJ0SW5kZXgiLCJsYXN0SW5kZXgiLCJsZW5ndGgiLCJsZW4iLCJpbmRleCIsInB1c2giLCJpc05hbWUiLCJpc0V4aXN0IiwidiIsImlzRW1wdHlPYmplY3QiLCJvYmoiLCJPYmplY3QiLCJrZXlzIiwibWVyZ2UiLCJ0YXJnZXQiLCJhIiwiYXJyYXlNb2RlIiwiaSIsImdldFZhbHVlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/fast-xml-parser/src/util.js\");\n\n\nconst defaultOptions = {\n    allowBooleanAttributes: false,\n    unpairedTags: []\n};\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nfunction validate(xmlData, options) {\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n    const tags = [];\n    let tagFound = false;\n    //indicates that the root tag has been closed (aka. depth 0 has been reached)\n    let reachedRoot = false;\n    if (xmlData[0] === \"\\uFEFF\") {\n        // check for byte order mark (BOM)\n        xmlData = xmlData.substr(1);\n    }\n    for(let i = 0; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\" && xmlData[i + 1] === \"?\") {\n            i += 2;\n            i = readPI(xmlData, i);\n            if (i.err) return i;\n        } else if (xmlData[i] === \"<\") {\n            //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            let tagStartPos = i;\n            i++;\n            if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {\n                    //closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for(; i < xmlData.length && xmlData[i] !== \">\" && xmlData[i] !== \" \" && xmlData[i] !== \"\t\" && xmlData[i] !== \"\\n\" && xmlData[i] !== \"\\r\"; i++){\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n                if (tagName[tagName.length - 1] === \"/\") {\n                    //self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    //continue;\n                    i--;\n                }\n                if (!validateTagName(tagName)) {\n                    let msg;\n                    if (tagName.trim().length === 0) {\n                        msg = \"Invalid space after '<'.\";\n                    } else {\n                        msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n                    }\n                    return getErrorObject(\"InvalidTag\", msg, getLineNumberForPosition(xmlData, i));\n                }\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return getErrorObject(\"InvalidAttr\", \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n                }\n                let attrStr = result.value;\n                i = result.index;\n                if (attrStr[attrStr.length - 1] === \"/\") {\n                    //self closing tag\n                    const attrStrStart = i - attrStr.length;\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                    //continue; //text may presents after self closing tag\n                    } else {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n                    }\n                } else if (closingTag) {\n                    if (!result.tagClosed) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n                    } else if (attrStr.trim().length > 0) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n                    } else if (tags.length === 0) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg.tagName) {\n                            let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n                            return getErrorObject(\"InvalidTag\", \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\", getLineNumberForPosition(xmlData, tagStartPos));\n                        }\n                        //when there are no more tags, we reached the root level.\n                        if (tags.length == 0) {\n                            reachedRoot = true;\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n                    }\n                    //if the root level has been reached before ...\n                    if (reachedRoot === true) {\n                        return getErrorObject(\"InvalidXml\", \"Multiple possible root nodes found.\", getLineNumberForPosition(xmlData, i));\n                    } else if (options.unpairedTags.indexOf(tagName) !== -1) {\n                    //don't push into stack\n                    } else {\n                        tags.push({\n                            tagName,\n                            tagStartPos\n                        });\n                    }\n                    tagFound = true;\n                }\n                //skip tag text value\n                //It may include comments and CDATA value\n                for(i++; i < xmlData.length; i++){\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {\n                            //comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else if (xmlData[i + 1] === \"?\") {\n                            i = readPI(xmlData, ++i);\n                            if (i.err) return i;\n                        } else {\n                            break;\n                        }\n                    } else if (xmlData[i] === \"&\") {\n                        const afterAmp = validateAmpersand(xmlData, i);\n                        if (afterAmp == -1) return getErrorObject(\"InvalidChar\", \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n                        i = afterAmp;\n                    } else {\n                        if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n                            return getErrorObject(\"InvalidXml\", \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n                        }\n                    }\n                } //end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (isWhiteSpace(xmlData[i])) {\n                continue;\n            }\n            return getErrorObject(\"InvalidChar\", \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n        }\n    }\n    if (!tagFound) {\n        return getErrorObject(\"InvalidXml\", \"Start tag expected.\", 1);\n    } else if (tags.length == 1) {\n        return getErrorObject(\"InvalidTag\", \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n    } else if (tags.length > 0) {\n        return getErrorObject(\"InvalidXml\", \"Invalid '\" + JSON.stringify(tags.map((t)=>t.tagName), null, 4).replace(/\\r?\\n/g, \"\") + \"' found.\", {\n            line: 1,\n            col: 1\n        });\n    }\n    return true;\n}\n;\nfunction isWhiteSpace(char) {\n    return char === \" \" || char === \"\t\" || char === \"\\n\" || char === \"\\r\";\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */ function readPI(xmlData, i) {\n    const start = i;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {\n            //tagname\n            const tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return getErrorObject(\"InvalidXml\", \"XML declaration allowed only at the start of the document.\", getLineNumberForPosition(xmlData, i));\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {\n        //comment\n        for(i += 3; i < xmlData.length; i++){\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 && xmlData[i + 1] === \"D\" && xmlData[i + 2] === \"O\" && xmlData[i + 3] === \"C\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"Y\" && xmlData[i + 6] === \"P\" && xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\") {\n                angleBracketsCount++;\n            } else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 && xmlData[i + 1] === \"[\" && xmlData[i + 2] === \"C\" && xmlData[i + 3] === \"D\" && xmlData[i + 4] === \"A\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"A\" && xmlData[i + 7] === \"[\") {\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n    return i;\n}\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */ function readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    let tagClosed = false;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                tagClosed = true;\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n    return {\n        value: attrStr,\n        index: i,\n        tagClosed: tagClosed\n    };\n}\n/**\n * Select all the attributes whether valid or invalid.\n */ const validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n    //if(attrStr.trim().length === 0) return true; //empty string\n    const matches = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getAllMatches)(attrStr, validAttrStrRegxp);\n    const attrNames = {};\n    for(let i = 0; i < matches.length; i++){\n        if (matches[i][1].length === 0) {\n            //nospace before attribute name: a=\"sd\"b=\"saf\"\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' is without value.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n            //independent attribute: ab\n            return getErrorObject(\"InvalidAttr\", \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */ const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {\n            //check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n        }\n    }\n    return true;\n}\nfunction validateNumberAmpersand(xmlData, i) {\n    let re = /\\d/;\n    if (xmlData[i] === \"x\") {\n        i++;\n        re = /[\\da-fA-F]/;\n    }\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \";\") return i;\n        if (!xmlData[i].match(re)) break;\n    }\n    return -1;\n}\nfunction validateAmpersand(xmlData, i) {\n    // https://www.w3.org/TR/xml/#dt-charref\n    i++;\n    if (xmlData[i] === \";\") return -1;\n    if (xmlData[i] === \"#\") {\n        i++;\n        return validateNumberAmpersand(xmlData, i);\n    }\n    let count = 0;\n    for(; i < xmlData.length; i++, count++){\n        if (xmlData[i].match(/\\w/) && count < 20) continue;\n        if (xmlData[i] === \";\") break;\n        return -1;\n    }\n    return i;\n}\nfunction getErrorObject(code, message, lineNumber) {\n    return {\n        err: {\n            code: code,\n            msg: message,\n            line: lineNumber.line || lineNumber,\n            col: lineNumber.col\n        }\n    };\n}\nfunction validateAttrName(attrName) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isName)(attrName);\n}\n// const startsWithXML = /^xml/i;\nfunction validateTagName(tagname) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isName)(tagname) /* && !tagname.match(startsWithXML) */ ;\n}\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n    const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n    return {\n        line: lines.length,\n        // column number is last line's length + 1, because column numbering starts at 1:\n        col: lines[lines.length - 1].length + 1\n    };\n}\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n    return match.startIndex + match[1].length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVnRDtBQUVoRCxNQUFNRSxpQkFBaUI7SUFDckJDLHdCQUF3QjtJQUN4QkMsY0FBYyxFQUFFO0FBQ2xCO0FBRUEscUVBQXFFO0FBQzlELFNBQVNDLFNBQVNDLE9BQU8sRUFBRUMsT0FBTztJQUN2Q0EsVUFBVUMsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1AsZ0JBQWdCSztJQUU1QyxzRUFBc0U7SUFDdEUsK0VBQStFO0lBQy9FLDZGQUE2RjtJQUM3RixNQUFNRyxPQUFPLEVBQUU7SUFDZixJQUFJQyxXQUFXO0lBRWYsNkVBQTZFO0lBQzdFLElBQUlDLGNBQWM7SUFFbEIsSUFBSU4sT0FBTyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzNCLGtDQUFrQztRQUNsQ0EsVUFBVUEsUUFBUU8sTUFBTSxDQUFDO0lBQzNCO0lBRUEsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLFFBQVFTLE1BQU0sRUFBRUQsSUFBSztRQUV2QyxJQUFJUixPQUFPLENBQUNRLEVBQUUsS0FBSyxPQUFPUixPQUFPLENBQUNRLElBQUUsRUFBRSxLQUFLLEtBQUs7WUFDOUNBLEtBQUc7WUFDSEEsSUFBSUUsT0FBT1YsU0FBUVE7WUFDbkIsSUFBSUEsRUFBRUcsR0FBRyxFQUFFLE9BQU9IO1FBQ3BCLE9BQU0sSUFBSVIsT0FBTyxDQUFDUSxFQUFFLEtBQUssS0FBSztZQUM1QixpQkFBaUI7WUFDakIsaUVBQWlFO1lBQ2pFLElBQUlJLGNBQWNKO1lBQ2xCQTtZQUVBLElBQUlSLE9BQU8sQ0FBQ1EsRUFBRSxLQUFLLEtBQUs7Z0JBQ3RCQSxJQUFJSyxvQkFBb0JiLFNBQVNRO2dCQUNqQztZQUNGLE9BQU87Z0JBQ0wsSUFBSU0sYUFBYTtnQkFDakIsSUFBSWQsT0FBTyxDQUFDUSxFQUFFLEtBQUssS0FBSztvQkFDdEIsYUFBYTtvQkFDYk0sYUFBYTtvQkFD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Q3pCaEMsS0FBS2dDLFdBQVdoQyxHQUFHO1FBQ3JCO0lBQ0Y7QUFDRjtBQUVBLFNBQVN5QixpQkFBaUJELFFBQVE7SUFDaEMsT0FBT2pFLGdEQUFNQSxDQUFDaUU7QUFDaEI7QUFFQSxpQ0FBaUM7QUFFakMsU0FBUzFDLGdCQUFnQitCLE9BQU87SUFDOUIsT0FBT3RELGdEQUFNQSxDQUFDc0QsU0FBUyxvQ0FBb0M7QUFDN0Q7QUFFQSw0RUFBNEU7QUFDNUUsU0FBUzVCLHlCQUF5QnJCLE9BQU8sRUFBRTBCLEtBQUs7SUFDOUMsTUFBTTJDLFFBQVFyRSxRQUFRaUIsU0FBUyxDQUFDLEdBQUdTLE9BQU80QyxLQUFLLENBQUM7SUFDaEQsT0FBTztRQUNMdkMsTUFBTXNDLE1BQU01RCxNQUFNO1FBRWxCLGlGQUFpRjtRQUNqRjJCLEtBQUtpQyxLQUFLLENBQUNBLE1BQU01RCxNQUFNLEdBQUcsRUFBRSxDQUFDQSxNQUFNLEdBQUc7SUFDeEM7QUFDRjtBQUVBLG1GQUFtRjtBQUNuRixTQUFTaUQscUJBQXFCTyxLQUFLO0lBQ2pDLE9BQU9BLE1BQU1NLFVBQVUsR0FBR04sS0FBSyxDQUFDLEVBQUUsQ0FBQ3hELE1BQU07QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydXJhbC1oZWFsdGgtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy92YWxpZGF0b3IuanM/N2U1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Z2V0QWxsTWF0Y2hlcywgaXNOYW1lfSBmcm9tICcuL3V0aWwuanMnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxsb3dCb29sZWFuQXR0cmlidXRlczogZmFsc2UsIC8vQSB0YWcgY2FuIGhhdmUgYXR0cmlidXRlcyB3aXRob3V0IGFueSB2YWx1ZVxuICB1bnBhaXJlZFRhZ3M6IFtdXG59O1xuXG4vL2NvbnN0IHRhZ3NQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIjxcXFxcLz8oW1xcXFx3OlxcXFwtX1xcLl0rKVxcXFxzKlxcLz8+XCIsXCJnXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHhtbERhdGEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAvL3htbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sXCJcIik7Ly9tYWtlIGl0IHNpbmdsZSBsaW5lXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKF5cXHMqPFxcP3htbC4qP1xcPz4pL2csXCJcIik7Ly9SZW1vdmUgWE1MIHN0YXJ0aW5nIHRhZ1xuICAvL3htbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoLyg8IURPQ1RZUEVbXFxzXFx3XFxcIlxcLlxcL1xcLVxcOl0rKFxcWy4qXFxdKSpcXHMqPikvZyxcIlwiKTsvL1JlbW92ZSBET0NUWVBFXG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgbGV0IHRhZ0ZvdW5kID0gZmFsc2U7XG5cbiAgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgcm9vdCB0YWcgaGFzIGJlZW4gY2xvc2VkIChha2EuIGRlcHRoIDAgaGFzIGJlZW4gcmVhY2hlZClcbiAgbGV0IHJlYWNoZWRSb290ID0gZmFsc2U7XG5cbiAgaWYgKHhtbERhdGFbMF0gPT09ICdcXHVmZWZmJykge1xuICAgIC8vIGNoZWNrIGZvciBieXRlIG9yZGVyIG1hcmsgKEJPTSlcbiAgICB4bWxEYXRhID0geG1sRGF0YS5zdWJzdHIoMSk7XG4gIH1cbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKHhtbERhdGFbaV0gPT09ICc8JyAmJiB4bWxEYXRhW2krMV0gPT09ICc/Jykge1xuICAgICAgaSs9MjtcbiAgICAgIGkgPSByZWFkUEkoeG1sRGF0YSxpKTtcbiAgICAgIGlmIChpLmVycikgcmV0dXJuIGk7XG4gICAgfWVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgLy9zdGFydGluZyBvZiB0YWdcbiAgICAgIC8vcmVhZCB1bnRpbCB5b3UgcmVhY2ggdG8gJz4nIGF2b2lkaW5nIGFueSAnPicgaW4gYXR0cmlidXRlIHZhbHVlXG4gICAgICBsZXQgdGFnU3RhcnRQb3MgPSBpO1xuICAgICAgaSsrO1xuICAgICAgXG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJyEnKSB7XG4gICAgICAgIGkgPSByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjbG9zaW5nVGFnID0gZmFsc2U7XG4gICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnLycpIHtcbiAgICAgICAgICAvL2Nsb3NpbmcgdGFnXG4gICAgICAgICAgY2xvc2luZ1RhZyA9IHRydWU7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVhZCB0YWduYW1lXG4gICAgICAgIGxldCB0YWdOYW1lID0gJyc7XG4gICAgICAgIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGggJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnPicgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnICcgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnXFx0JyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICdcXG4nICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJ1xccic7IGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICB0YWdOYW1lICs9IHhtbERhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudHJpbSgpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRhZ05hbWUpO1xuXG4gICAgICAgIGlmICh0YWdOYW1lW3RhZ05hbWUubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgICAgIC8vc2VsZiBjbG9zaW5nIHRhZyB3aXRob3V0IGF0dHJpYnV0ZXNcbiAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHJpbmcoMCwgdGFnTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAvL2NvbnRpbnVlO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbGlkYXRlVGFnTmFtZSh0YWdOYW1lKSkge1xuICAgICAgICAgIGxldCBtc2c7XG4gICAgICAgICAgaWYgKHRhZ05hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbXNnID0gXCJJbnZhbGlkIHNwYWNlIGFmdGVyICc8Jy5cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNnID0gXCJUYWcgJ1wiK3RhZ05hbWUrXCInIGlzIGFuIGludmFsaWQgbmFtZS5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgbXNnLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZEF0dHJpYnV0ZVN0cih4bWxEYXRhLCBpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGVzIGZvciAnXCIrdGFnTmFtZStcIicgaGF2ZSBvcGVuIHF1b3RlLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhdHRyU3RyID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpID0gcmVzdWx0LmluZGV4O1xuXG4gICAgICAgIGlmIChhdHRyU3RyW2F0dHJTdHIubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgICAgIC8vc2VsZiBjbG9zaW5nIHRhZ1xuICAgICAgICAgIGNvbnN0IGF0dHJTdHJTdGFydCA9IGkgLSBhdHRyU3RyLmxlbmd0aDtcbiAgICAgICAgICBhdHRyU3RyID0gYXR0clN0ci5zdWJzdHJpbmcoMCwgYXR0clN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGlzVmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRhZ0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29udGludWU7IC8vdGV4dCBtYXkgcHJlc2VudHMgYWZ0ZXIgc2VsZiBjbG9zaW5nIHRhZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3RoZSByZXN1bHQgZnJvbSB0aGUgbmVzdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBlcnJvciB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy9pbiBvcmRlciB0byBnZXQgdGhlICd0cnVlJyBlcnJvciBsaW5lLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGF0dHJpYnV0ZSBiZWdpbnMgKGkgLSBhdHRyU3RyLmxlbmd0aCkgYW5kIHRoZW4gYWRkIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy90aGlzIGdpdmVzIHVzIHRoZSBhYnNvbHV0ZSBpbmRleCBpbiB0aGUgZW50aXJlIHhtbCwgd2hpY2ggd2UgY2FuIHVzZSB0byBmaW5kIHRoZSBsaW5lIGF0IGxhc3RcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdChpc1ZhbGlkLmVyci5jb2RlLCBpc1ZhbGlkLmVyci5tc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBhdHRyU3RyU3RhcnQgKyBpc1ZhbGlkLmVyci5saW5lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNsb3NpbmdUYWcpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdC50YWdDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiQ2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInIGRvZXNuJ3QgaGF2ZSBwcm9wZXIgY2xvc2luZy5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJTdHIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiQ2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInIGNhbid0IGhhdmUgYXR0cmlidXRlcyBvciBpbnZhbGlkIHN0YXJ0aW5nLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgdGFnU3RhcnRQb3MpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBcIkNsb3NpbmcgdGFnICdcIit0YWdOYW1lK1wiJyBoYXMgbm90IGJlZW4gb3BlbmVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgdGFnU3RhcnRQb3MpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3RnID0gdGFncy5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lICE9PSBvdGcudGFnTmFtZSkge1xuICAgICAgICAgICAgICBsZXQgb3BlblBvcyA9IGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBvdGcudGFnU3RhcnRQb3MpO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgY2xvc2luZyB0YWcgJ1wiK290Zy50YWdOYW1lK1wiJyAob3BlbmVkIGluIGxpbmUgXCIrb3BlblBvcy5saW5lK1wiLCBjb2wgXCIrb3BlblBvcy5jb2wrXCIpIGluc3RlYWQgb2YgY2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInLlwiLFxuICAgICAgICAgICAgICAgIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdTdGFydFBvcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3doZW4gdGhlcmUgYXJlIG5vIG1vcmUgdGFncywgd2UgcmVhY2hlZCB0aGUgcm9vdCBsZXZlbC5cbiAgICAgICAgICAgIGlmICh0YWdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJlYWNoZWRSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlQXR0cmlidXRlU3RyaW5nKGF0dHJTdHIsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChpc1ZhbGlkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL3RoZSByZXN1bHQgZnJvbSB0aGUgbmVzdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBlcnJvciB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy9pbiBvcmRlciB0byBnZXQgdGhlICd0cnVlJyBlcnJvciBsaW5lLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGF0dHJpYnV0ZSBiZWdpbnMgKGkgLSBhdHRyU3RyLmxlbmd0aCkgYW5kIHRoZW4gYWRkIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy90aGlzIGdpdmVzIHVzIHRoZSBhYnNvbHV0ZSBpbmRleCBpbiB0aGUgZW50aXJlIHhtbCwgd2hpY2ggd2UgY2FuIHVzZSB0byBmaW5kIHRoZSBsaW5lIGF0IGxhc3RcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdChpc1ZhbGlkLmVyci5jb2RlLCBpc1ZhbGlkLmVyci5tc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpIC0gYXR0clN0ci5sZW5ndGggKyBpc1ZhbGlkLmVyci5saW5lKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9pZiB0aGUgcm9vdCBsZXZlbCBoYXMgYmVlbiByZWFjaGVkIGJlZm9yZSAuLi5cbiAgICAgICAgICBpZiAocmVhY2hlZFJvb3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsICdNdWx0aXBsZSBwb3NzaWJsZSByb290IG5vZGVzIGZvdW5kLicsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKG9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xKXtcbiAgICAgICAgICAgIC8vZG9uJ3QgcHVzaCBpbnRvIHN0YWNrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhZ3MucHVzaCh7dGFnTmFtZSwgdGFnU3RhcnRQb3N9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9za2lwIHRhZyB0ZXh0IHZhbHVlXG4gICAgICAgIC8vSXQgbWF5IGluY2x1ZGUgY29tbWVudHMgYW5kIENEQVRBIHZhbHVlXG4gICAgICAgIGZvciAoaSsrOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgICAgIGlmICh4bWxEYXRhW2kgKyAxXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgIC8vY29tbWVudCBvciBDQURBVEFcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBpID0gcmVhZENvbW1lbnRBbmRDREFUQSh4bWxEYXRhLCBpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgIGkgPSByZWFkUEkoeG1sRGF0YSwgKytpKTtcbiAgICAgICAgICAgICAgaWYgKGkuZXJyKSByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnJicpIHtcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQW1wID0gdmFsaWRhdGVBbXBlcnNhbmQoeG1sRGF0YSwgaSk7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJBbXAgPT0gLTEpXG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZENoYXInLCBcImNoYXIgJyYnIGlzIG5vdCBleHBlY3RlZC5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICAgIGkgPSBhZnRlckFtcDtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmIChyZWFjaGVkUm9vdCA9PT0gdHJ1ZSAmJiAhaXNXaGl0ZVNwYWNlKHhtbERhdGFbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsIFwiRXh0cmEgdGV4dCBhdCB0aGUgZW5kXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vZW5kIG9mIHJlYWRpbmcgdGFnIHRleHQgdmFsdWVcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIGlzV2hpdGVTcGFjZSh4bWxEYXRhW2ldKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZENoYXInLCBcImNoYXIgJ1wiK3htbERhdGFbaV0rXCInIGlzIG5vdCBleHBlY3RlZC5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhZ0ZvdW5kKSB7XG4gICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ1N0YXJ0IHRhZyBleHBlY3RlZC4nLCAxKTtcbiAgfWVsc2UgaWYgKHRhZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiVW5jbG9zZWQgdGFnICdcIit0YWdzWzBdLnRhZ05hbWUrXCInLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgdGFnc1swXS50YWdTdGFydFBvcykpO1xuICB9ZWxzZSBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCBcIkludmFsaWQgJ1wiK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRhZ3MubWFwKHQgPT4gdC50YWdOYW1lKSwgbnVsbCwgNCkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJykrXG4gICAgICAgICAgXCInIGZvdW5kLlwiLCB7bGluZTogMSwgY29sOiAxfSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaGFyKXtcbiAgcmV0dXJuIGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnXFxuJyAgfHwgY2hhciA9PT0gJ1xccic7XG59XG4vKipcbiAqIFJlYWQgUHJvY2Vzc2luZyBpbnNzdHJ1Y3Rpb25zIGFuZCBza2lwXG4gKiBAcGFyYW0geyp9IHhtbERhdGFcbiAqIEBwYXJhbSB7Kn0gaVxuICovXG5mdW5jdGlvbiByZWFkUEkoeG1sRGF0YSwgaSkge1xuICBjb25zdCBzdGFydCA9IGk7XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4bWxEYXRhW2ldID09ICc/JyB8fCB4bWxEYXRhW2ldID09ICcgJykge1xuICAgICAgLy90YWduYW1lXG4gICAgICBjb25zdCB0YWduYW1lID0geG1sRGF0YS5zdWJzdHIoc3RhcnQsIGkgLSBzdGFydCk7XG4gICAgICBpZiAoaSA+IDUgJiYgdGFnbmFtZSA9PT0gJ3htbCcpIHtcbiAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ1hNTCBkZWNsYXJhdGlvbiBhbGxvd2VkIG9ubHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC4nLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09ICc/JyAmJiB4bWxEYXRhW2kgKyAxXSA9PSAnPicpIHtcbiAgICAgICAgLy9jaGVjayBpZiB2YWxpZCBhdHRyaWJ1dCBzdHJpbmdcbiAgICAgICAgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gcmVhZENvbW1lbnRBbmRDREFUQSh4bWxEYXRhLCBpKSB7XG4gIGlmICh4bWxEYXRhLmxlbmd0aCA+IGkgKyA1ICYmIHhtbERhdGFbaSArIDFdID09PSAnLScgJiYgeG1sRGF0YVtpICsgMl0gPT09ICctJykge1xuICAgIC8vY29tbWVudFxuICAgIGZvciAoaSArPSAzOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICctJyAmJiB4bWxEYXRhW2kgKyAxXSA9PT0gJy0nICYmIHhtbERhdGFbaSArIDJdID09PSAnPicpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgeG1sRGF0YS5sZW5ndGggPiBpICsgOCAmJlxuICAgIHhtbERhdGFbaSArIDFdID09PSAnRCcgJiZcbiAgICB4bWxEYXRhW2kgKyAyXSA9PT0gJ08nICYmXG4gICAgeG1sRGF0YVtpICsgM10gPT09ICdDJyAmJlxuICAgIHhtbERhdGFbaSArIDRdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2kgKyA1XSA9PT0gJ1knICYmXG4gICAgeG1sRGF0YVtpICsgNl0gPT09ICdQJyAmJlxuICAgIHhtbERhdGFbaSArIDddID09PSAnRSdcbiAgKSB7XG4gICAgbGV0IGFuZ2xlQnJhY2tldHNDb3VudCA9IDE7XG4gICAgZm9yIChpICs9IDg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudCsrO1xuICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnPicpIHtcbiAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50LS07XG4gICAgICAgIGlmIChhbmdsZUJyYWNrZXRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB4bWxEYXRhLmxlbmd0aCA+IGkgKyA5ICYmXG4gICAgeG1sRGF0YVtpICsgMV0gPT09ICdbJyAmJlxuICAgIHhtbERhdGFbaSArIDJdID09PSAnQycgJiZcbiAgICB4bWxEYXRhW2kgKyAzXSA9PT0gJ0QnICYmXG4gICAgeG1sRGF0YVtpICsgNF0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSArIDVdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpICsgN10gPT09ICdbJ1xuICApIHtcbiAgICBmb3IgKGkgKz0gODsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnXScgJiYgeG1sRGF0YVtpICsgMV0gPT09ICddJyAmJiB4bWxEYXRhW2kgKyAyXSA9PT0gJz4nKSB7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGk7XG59XG5cbmNvbnN0IGRvdWJsZVF1b3RlID0gJ1wiJztcbmNvbnN0IHNpbmdsZVF1b3RlID0gXCInXCI7XG5cbi8qKlxuICogS2VlcCByZWFkaW5nIHhtbERhdGEgdW50aWwgJzwnIGlzIGZvdW5kIG91dHNpZGUgdGhlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxEYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5mdW5jdGlvbiByZWFkQXR0cmlidXRlU3RyKHhtbERhdGEsIGkpIHtcbiAgbGV0IGF0dHJTdHIgPSAnJztcbiAgbGV0IHN0YXJ0Q2hhciA9ICcnO1xuICBsZXQgdGFnQ2xvc2VkID0gZmFsc2U7XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4bWxEYXRhW2ldID09PSBkb3VibGVRdW90ZSB8fCB4bWxEYXRhW2ldID09PSBzaW5nbGVRdW90ZSkge1xuICAgICAgaWYgKHN0YXJ0Q2hhciA9PT0gJycpIHtcbiAgICAgICAgc3RhcnRDaGFyID0geG1sRGF0YVtpXTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRDaGFyICE9PSB4bWxEYXRhW2ldKSB7XG4gICAgICAgIC8vaWYgdmF1ZSBpcyBlbmNsb3NlZCB3aXRoIGRvdWJsZSBxdW90ZSB0aGVuIHNpbmdsZSBxdW90ZXMgYXJlIGFsbG93ZWQgaW5zaWRlIHRoZSB2YWx1ZSBhbmQgdmljZSB2ZXJzYVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRDaGFyID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnPicpIHtcbiAgICAgIGlmIChzdGFydENoYXIgPT09ICcnKSB7XG4gICAgICAgIHRhZ0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyU3RyICs9IHhtbERhdGFbaV07XG4gIH1cbiAgaWYgKHN0YXJ0Q2hhciAhPT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBhdHRyU3RyLFxuICAgIGluZGV4OiBpLFxuICAgIHRhZ0Nsb3NlZDogdGFnQ2xvc2VkXG4gIH07XG59XG5cbi8qKlxuICogU2VsZWN0IGFsbCB0aGUgYXR0cmlidXRlcyB3aGV0aGVyIHZhbGlkIG9yIGludmFsaWQuXG4gKi9cbmNvbnN0IHZhbGlkQXR0clN0clJlZ3hwID0gbmV3IFJlZ0V4cCgnKFxcXFxzKikoW15cXFxccz1dKykoXFxcXHMqPSk/KFxcXFxzKihbXFwnXCJdKSgoW1xcXFxzXFxcXFNdKSo/KVxcXFw1KT8nLCAnZycpO1xuXG4vL2F0dHIsID1cInNkXCIsIGE9XCJhbWl0J3NcIiwgYT1cInNkXCJiPVwic2FmXCIsIGFiICBjZD1cIlwiXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXR0cmlidXRlU3RyaW5nKGF0dHJTdHIsIG9wdGlvbnMpIHtcbiAgLy9jb25zb2xlLmxvZyhcInN0YXJ0OlwiK2F0dHJTdHIrXCI6ZW5kXCIpO1xuXG4gIC8vaWYoYXR0clN0ci50cmltKCkubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTsgLy9lbXB0eSBzdHJpbmdcblxuICBjb25zdCBtYXRjaGVzID0gZ2V0QWxsTWF0Y2hlcyhhdHRyU3RyLCB2YWxpZEF0dHJTdHJSZWd4cCk7XG4gIGNvbnN0IGF0dHJOYW1lcyA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXRjaGVzW2ldWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy9ub3NwYWNlIGJlZm9yZSBhdHRyaWJ1dGUgbmFtZTogYT1cInNkXCJiPVwic2FmXCJcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrbWF0Y2hlc1tpXVsyXStcIicgaGFzIG5vIHNwYWNlIGluIHN0YXJ0aW5nLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSlcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXNbaV1bM10gIT09IHVuZGVmaW5lZCAmJiBtYXRjaGVzW2ldWzRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrbWF0Y2hlc1tpXVsyXStcIicgaXMgd2l0aG91dCB2YWx1ZS5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlc1tpXVszXSA9PT0gdW5kZWZpbmVkICYmICFvcHRpb25zLmFsbG93Qm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vaW5kZXBlbmRlbnQgYXR0cmlidXRlOiBhYlxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiYm9vbGVhbiBhdHRyaWJ1dGUgJ1wiK21hdGNoZXNbaV1bMl0rXCInIGlzIG5vdCBhbGxvd2VkLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfVxuICAgIC8qIGVsc2UgaWYobWF0Y2hlc1tpXVs2XSA9PT0gdW5kZWZpbmVkKXsvL2F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlOiBhYj1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyOiB7IGNvZGU6XCJJbnZhbGlkQXR0clwiLG1zZzpcImF0dHJpYnV0ZSBcIiArIG1hdGNoZXNbaV1bMl0gKyBcIiBoYXMgbm8gdmFsdWUgYXNzaWduZWQuXCJ9fTtcbiAgICAgICAgICAgICAgICB9ICovXG4gICAgY29uc3QgYXR0ck5hbWUgPSBtYXRjaGVzW2ldWzJdO1xuICAgIGlmICghdmFsaWRhdGVBdHRyTmFtZShhdHRyTmFtZSkpIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrYXR0ck5hbWUrXCInIGlzIGFuIGludmFsaWQgbmFtZS5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH1cbiAgICBpZiAoIWF0dHJOYW1lcy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcbiAgICAgIC8vY2hlY2sgZm9yIGR1cGxpY2F0ZSBhdHRyaWJ1dGUuXG4gICAgICBhdHRyTmFtZXNbYXR0ck5hbWVdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIithdHRyTmFtZStcIicgaXMgcmVwZWF0ZWQuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXJBbXBlcnNhbmQoeG1sRGF0YSwgaSkge1xuICBsZXQgcmUgPSAvXFxkLztcbiAgaWYgKHhtbERhdGFbaV0gPT09ICd4Jykge1xuICAgIGkrKztcbiAgICByZSA9IC9bXFxkYS1mQS1GXS87XG4gIH1cbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09ICc7JylcbiAgICAgIHJldHVybiBpO1xuICAgIGlmICgheG1sRGF0YVtpXS5tYXRjaChyZSkpXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQW1wZXJzYW5kKHhtbERhdGEsIGkpIHtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jZHQtY2hhcnJlZlxuICBpKys7XG4gIGlmICh4bWxEYXRhW2ldID09PSAnOycpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAoeG1sRGF0YVtpXSA9PT0gJyMnKSB7XG4gICAgaSsrO1xuICAgIHJldHVybiB2YWxpZGF0ZU51bWJlckFtcGVyc2FuZCh4bWxEYXRhLCBpKTtcbiAgfVxuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyssIGNvdW50KyspIHtcbiAgICBpZiAoeG1sRGF0YVtpXS5tYXRjaCgvXFx3LykgJiYgY291bnQgPCAyMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh4bWxEYXRhW2ldID09PSAnOycpXG4gICAgICBicmVhaztcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGdldEVycm9yT2JqZWN0KGNvZGUsIG1lc3NhZ2UsIGxpbmVOdW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBlcnI6IHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBtc2c6IG1lc3NhZ2UsXG4gICAgICBsaW5lOiBsaW5lTnVtYmVyLmxpbmUgfHwgbGluZU51bWJlcixcbiAgICAgIGNvbDogbGluZU51bWJlci5jb2wsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBdHRyTmFtZShhdHRyTmFtZSkge1xuICByZXR1cm4gaXNOYW1lKGF0dHJOYW1lKTtcbn1cblxuLy8gY29uc3Qgc3RhcnRzV2l0aFhNTCA9IC9eeG1sL2k7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFnTmFtZSh0YWduYW1lKSB7XG4gIHJldHVybiBpc05hbWUodGFnbmFtZSkgLyogJiYgIXRhZ25hbWUubWF0Y2goc3RhcnRzV2l0aFhNTCkgKi87XG59XG5cbi8vdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBsaW5lIG51bWJlciBmb3IgdGhlIGNoYXJhY3RlciBhdCB0aGUgZ2l2ZW4gaW5kZXhcbmZ1bmN0aW9uIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpbmRleCkge1xuICBjb25zdCBsaW5lcyA9IHhtbERhdGEuc3Vic3RyaW5nKDAsIGluZGV4KS5zcGxpdCgvXFxyP1xcbi8pO1xuICByZXR1cm4ge1xuICAgIGxpbmU6IGxpbmVzLmxlbmd0aCxcblxuICAgIC8vIGNvbHVtbiBudW1iZXIgaXMgbGFzdCBsaW5lJ3MgbGVuZ3RoICsgMSwgYmVjYXVzZSBjb2x1bW4gbnVtYmVyaW5nIHN0YXJ0cyBhdCAxOlxuICAgIGNvbDogbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoICsgMVxuICB9O1xufVxuXG4vL3RoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBtYXRjaCB3aXRoaW4gYXR0clN0clxuZnVuY3Rpb24gZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2gpIHtcbiAgcmV0dXJuIG1hdGNoLnN0YXJ0SW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG59XG4iXSwibmFtZXMiOlsiZ2V0QWxsTWF0Y2hlcyIsImlzTmFtZSIsImRlZmF1bHRPcHRpb25zIiwiYWxsb3dCb29sZWFuQXR0cmlidXRlcyIsInVucGFpcmVkVGFncyIsInZhbGlkYXRlIiwieG1sRGF0YSIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJ0YWdzIiwidGFnRm91bmQiLCJyZWFjaGVkUm9vdCIsInN1YnN0ciIsImkiLCJsZW5ndGgiLCJyZWFkUEkiLCJlcnIiLCJ0YWdTdGFydFBvcyIsInJlYWRDb21tZW50QW5kQ0RBVEEiLCJjbG9zaW5nVGFnIiwidGFnTmFtZSIsInRyaW0iLCJzdWJzdHJpbmciLCJ2YWxpZGF0ZVRhZ05hbWUiLCJtc2ciLCJnZXRFcnJvck9iamVjdCIsImdldExpbmVOdW1iZXJGb3JQb3NpdGlvbiIsInJlc3VsdCIsInJlYWRBdHRyaWJ1dGVTdHIiLCJhdHRyU3RyIiwidmFsdWUiLCJpbmRleCIsImF0dHJTdHJTdGFydCIsImlzVmFsaWQiLCJ2YWxpZGF0ZUF0dHJpYnV0ZVN0cmluZyIsImNvZGUiLCJsaW5lIiwidGFnQ2xvc2VkIiwib3RnIiwicG9wIiwib3BlblBvcyIsImNvbCIsImluZGV4T2YiLCJwdXNoIiwiYWZ0ZXJBbXAiLCJ2YWxpZGF0ZUFtcGVyc2FuZCIsImlzV2hpdGVTcGFjZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYXAiLCJ0IiwicmVwbGFjZSIsImNoYXIiLCJzdGFydCIsInRhZ25hbWUiLCJhbmdsZUJyYWNrZXRzQ291bnQiLCJkb3VibGVRdW90ZSIsInNpbmdsZVF1b3RlIiwic3RhcnRDaGFyIiwidmFsaWRBdHRyU3RyUmVneHAiLCJSZWdFeHAiLCJtYXRjaGVzIiwiYXR0ck5hbWVzIiwiZ2V0UG9zaXRpb25Gcm9tTWF0Y2giLCJ1bmRlZmluZWQiLCJhdHRyTmFtZSIsInZhbGlkYXRlQXR0ck5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInZhbGlkYXRlTnVtYmVyQW1wZXJzYW5kIiwicmUiLCJtYXRjaCIsImNvdW50IiwibWVzc2FnZSIsImxpbmVOdW1iZXIiLCJsaW5lcyIsInNwbGl0Iiwic3RhcnRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ readDocType)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"(rsc)/./node_modules/fast-xml-parser/src/util.js\");\n\n//TODO: handle comments\nfunction readDocType(xmlData, i) {\n    const entities = {};\n    if (xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"C\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"Y\" && xmlData[i + 7] === \"P\" && xmlData[i + 8] === \"E\") {\n        i = i + 9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\" && !comment) {\n                if (hasBody && hasSeq(xmlData, \"!ENTITY\", i)) {\n                    i += 7;\n                    let entityName, val;\n                    [entityName, val, i] = readEntityExp(xmlData, i + 1);\n                    if (val.indexOf(\"&\") === -1) entities[entityName] = {\n                        regx: RegExp(`&${entityName};`, \"g\"),\n                        val: val\n                    };\n                } else if (hasBody && hasSeq(xmlData, \"!ELEMENT\", i)) {\n                    i += 8; //Not supported\n                    const { index } = readElementExp(xmlData, i + 1);\n                    i = index;\n                } else if (hasBody && hasSeq(xmlData, \"!ATTLIST\", i)) {\n                    i += 8; //Not supported\n                // const {index} = readAttlistExp(xmlData,i+1);\n                // i = index;\n                } else if (hasBody && hasSeq(xmlData, \"!NOTATION\", i)) {\n                    i += 9; //Not supported\n                    const { index } = readNotationExp(xmlData, i + 1);\n                    i = index;\n                } else if (hasSeq(xmlData, \"!--\", i)) comment = true;\n                else throw new Error(`Invalid DOCTYPE`);\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === \">\") {\n                if (comment) {\n                    if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                } else {\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            } else if (xmlData[i] === \"[\") {\n                hasBody = true;\n            } else {\n                exp += xmlData[i];\n            }\n        }\n        if (angleBracketsCount !== 0) {\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    } else {\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {\n        entities,\n        i\n    };\n}\nconst skipWhitespace = (data, index)=>{\n    while(index < data.length && /\\s/.test(data[index])){\n        index++;\n    }\n    return index;\n};\nfunction readEntityExp(xmlData, i) {\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    // Skip leading whitespace after <!ENTITY\n    i = skipWhitespace(xmlData, i);\n    // Read entity name\n    let entityName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\"){\n        entityName += xmlData[i];\n        i++;\n    }\n    validateEntityName(entityName);\n    // Skip whitespace after entity name\n    i = skipWhitespace(xmlData, i);\n    // Check for unsupported constructs (external entities or parameter entities)\n    if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n        throw new Error(\"External entities are not supported\");\n    } else if (xmlData[i] === \"%\") {\n        throw new Error(\"Parameter entities are not supported\");\n    }\n    // Read entity value (internal entity)\n    let entityValue = \"\";\n    [i, entityValue] = readIdentifierVal(xmlData, i, \"entity\");\n    i--;\n    return [\n        entityName,\n        entityValue,\n        i\n    ];\n}\nfunction readNotationExp(xmlData, i) {\n    // Skip leading whitespace after <!NOTATION\n    i = skipWhitespace(xmlData, i);\n    // Read notation name\n    let notationName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        notationName += xmlData[i];\n        i++;\n    }\n    validateEntityName(notationName);\n    // Skip whitespace after notation name\n    i = skipWhitespace(xmlData, i);\n    // Check identifier type (SYSTEM or PUBLIC)\n    const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n    if (identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n        throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n    }\n    i += identifierType.length;\n    // Skip whitespace after identifier type\n    i = skipWhitespace(xmlData, i);\n    // Read public identifier (if PUBLIC)\n    let publicIdentifier = null;\n    let systemIdentifier = null;\n    if (identifierType === \"PUBLIC\") {\n        [i, publicIdentifier] = readIdentifierVal(xmlData, i, \"publicIdentifier\");\n        // Skip whitespace after public identifier\n        i = skipWhitespace(xmlData, i);\n        // Optionally read system identifier\n        if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n            [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n        }\n    } else if (identifierType === \"SYSTEM\") {\n        // Read system identifier (mandatory for SYSTEM)\n        [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n        if (!systemIdentifier) {\n            throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n        }\n    }\n    return {\n        notationName,\n        publicIdentifier,\n        systemIdentifier,\n        index: --i\n    };\n}\nfunction readIdentifierVal(xmlData, i, type) {\n    let identifierVal = \"\";\n    const startChar = xmlData[i];\n    if (startChar !== '\"' && startChar !== \"'\") {\n        throw new Error(`Expected quoted string, found \"${startChar}\"`);\n    }\n    i++;\n    while(i < xmlData.length && xmlData[i] !== startChar){\n        identifierVal += xmlData[i];\n        i++;\n    }\n    if (xmlData[i] !== startChar) {\n        throw new Error(`Unterminated ${type} value`);\n    }\n    i++;\n    return [\n        i,\n        identifierVal\n    ];\n}\nfunction readElementExp(xmlData, i) {\n    // <!ELEMENT br EMPTY>\n    // <!ELEMENT div ANY>\n    // <!ELEMENT title (#PCDATA)>\n    // <!ELEMENT book (title, author+)>\n    // <!ELEMENT name (content-model)>\n    // Skip leading whitespace after <!ELEMENT\n    i = skipWhitespace(xmlData, i);\n    // Read element name\n    let elementName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        elementName += xmlData[i];\n        i++;\n    }\n    // Validate element name\n    if (!validateEntityName(elementName)) {\n        throw new Error(`Invalid element name: \"${elementName}\"`);\n    }\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    let contentModel = \"\";\n    // Expect '(' to start content model\n    if (xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\", i)) i += 4;\n    else if (xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\", i)) i += 2;\n    else if (xmlData[i] === \"(\") {\n        i++; // Move past '('\n        // Read content model\n        while(i < xmlData.length && xmlData[i] !== \")\"){\n            contentModel += xmlData[i];\n            i++;\n        }\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated content model\");\n        }\n    } else {\n        throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n    }\n    return {\n        elementName,\n        contentModel: contentModel.trim(),\n        index: i\n    };\n}\nfunction readAttlistExp(xmlData, i) {\n    // Skip leading whitespace after <!ATTLIST\n    i = skipWhitespace(xmlData, i);\n    // Read element name\n    let elementName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        elementName += xmlData[i];\n        i++;\n    }\n    // Validate element name\n    validateEntityName(elementName);\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    // Read attribute name\n    let attributeName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        attributeName += xmlData[i];\n        i++;\n    }\n    // Validate attribute name\n    if (!validateEntityName(attributeName)) {\n        throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n    }\n    // Skip whitespace after attribute name\n    i = skipWhitespace(xmlData, i);\n    // Read attribute type\n    let attributeType = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n        attributeType = \"NOTATION\";\n        i += 8; // Move past \"NOTATION\"\n        // Skip whitespace after \"NOTATION\"\n        i = skipWhitespace(xmlData, i);\n        // Expect '(' to start the list of notations\n        if (xmlData[i] !== \"(\") {\n            throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n        }\n        i++; // Move past '('\n        // Read the list of allowed notations\n        let allowedNotations = [];\n        while(i < xmlData.length && xmlData[i] !== \")\"){\n            let notation = \"\";\n            while(i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\"){\n                notation += xmlData[i];\n                i++;\n            }\n            // Validate notation name\n            notation = notation.trim();\n            if (!validateEntityName(notation)) {\n                throw new Error(`Invalid notation name: \"${notation}\"`);\n            }\n            allowedNotations.push(notation);\n            // Skip '|' separator or exit loop\n            if (xmlData[i] === \"|\") {\n                i++; // Move past '|'\n                i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n            }\n        }\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated list of notations\");\n        }\n        i++; // Move past ')'\n        // Store the allowed notations as part of the attribute type\n        attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n    } else {\n        // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n        while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n            attributeType += xmlData[i];\n            i++;\n        }\n        // Validate simple attribute type\n        const validTypes = [\n            \"CDATA\",\n            \"ID\",\n            \"IDREF\",\n            \"IDREFS\",\n            \"ENTITY\",\n            \"ENTITIES\",\n            \"NMTOKEN\",\n            \"NMTOKENS\"\n        ];\n        if (!validTypes.includes(attributeType.toUpperCase())) {\n            throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n        }\n    }\n    // Skip whitespace after attribute type\n    i = skipWhitespace(xmlData, i);\n    // Read default value\n    let defaultValue = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n        defaultValue = \"#REQUIRED\";\n        i += 8;\n    } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n        defaultValue = \"#IMPLIED\";\n        i += 7;\n    } else {\n        [i, defaultValue] = readIdentifierVal(xmlData, i, \"ATTLIST\");\n    }\n    return {\n        elementName,\n        attributeName,\n        attributeType,\n        defaultValue,\n        index: i\n    };\n}\nfunction hasSeq(data, seq, i) {\n    for(let j = 0; j < seq.length; j++){\n        if (seq[j] !== data[i + j + 1]) return false;\n    }\n    return true;\n}\nfunction validateEntityName(name) {\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isName)(name)) return name;\n    else throw new Error(`Invalid entity name ${name}`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvRG9jVHlwZVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUVsQyx1QkFBdUI7QUFDUixTQUFTQyxZQUFZQyxPQUFPLEVBQUVDLENBQUM7SUFFMUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUlGLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssT0FDbEJELE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssT0FDbkJELE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssT0FDbkJELE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssT0FDbkJELE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssT0FDbkJELE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssS0FDeEI7UUFDSUEsSUFBSUEsSUFBRTtRQUNOLElBQUlFLHFCQUFxQjtRQUN6QixJQUFJQyxVQUFVLE9BQU9DLFVBQVU7UUFDL0IsSUFBSUMsTUFBTTtRQUNWLE1BQUtMLElBQUVELFFBQVFPLE1BQU0sRUFBQ04sSUFBSTtZQUN0QixJQUFJRCxPQUFPLENBQUNDLEVBQUUsS0FBSyxPQUFPLENBQUNJLFNBQVM7Z0JBQ2hDLElBQUlELFdBQVdJLE9BQU9SLFNBQVMsV0FBVUMsSUFBRztvQkFDeENBLEtBQUs7b0JBQ0wsSUFBSVEsWUFBWUM7b0JBQ2hCLENBQUNELFlBQVlDLEtBQUlULEVBQUUsR0FBR1UsY0FBY1gsU0FBUUMsSUFBRTtvQkFDOUMsSUFBR1MsSUFBSUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUNyQlYsUUFBUSxDQUFFTyxXQUFZLEdBQUc7d0JBQ3JCSSxNQUFPQyxPQUFRLENBQUMsQ0FBQyxFQUFFTCxXQUFXLENBQUMsQ0FBQyxFQUFDO3dCQUNqQ0MsS0FBS0E7b0JBQ1Q7Z0JBQ1IsT0FDSyxJQUFJTixXQUFXSSxPQUFPUixTQUFTLFlBQVdDLElBQUs7b0JBQ2hEQSxLQUFLLEdBQUUsZUFBZTtvQkFDdEIs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Q2Y3QyxLQUFLO0lBQ1QsT0FBTyxJQUFJRCxRQUFRdUIsU0FBUyxDQUFDdEIsR0FBR0EsSUFBSSxHQUFHdUIsV0FBVyxPQUFPLFlBQVk7UUFDakVzQixlQUFlO1FBQ2Y3QyxLQUFLO0lBQ1QsT0FBTztRQUNILENBQUNBLEdBQUc2QyxhQUFhLEdBQUdwQixrQkFBa0IxQixTQUFTQyxHQUFHO0lBQ3REO0lBRUEsT0FBTztRQUNIaUM7UUFDQUk7UUFDQUM7UUFDQU87UUFDQS9CLE9BQU9kO0lBQ1g7QUFDSjtBQUVBLFNBQVNPLE9BQU9ZLElBQUksRUFBRTJCLEdBQUcsRUFBQzlDLENBQUM7SUFDdkIsSUFBSSxJQUFJK0MsSUFBRSxHQUFFQSxJQUFFRCxJQUFJeEMsTUFBTSxFQUFDeUMsSUFBSTtRQUN6QixJQUFHRCxHQUFHLENBQUNDLEVBQUUsS0FBRzVCLElBQUksQ0FBQ25CLElBQUUrQyxJQUFFLEVBQUUsRUFBRSxPQUFPO0lBQ3BDO0lBQ0EsT0FBTztBQUNYO0FBRUEsU0FBUzFCLG1CQUFtQjJCLElBQUk7SUFDNUIsSUFBSW5ELGdEQUFNQSxDQUFDbUQsT0FDZCxPQUFPQTtTQUVBLE1BQU0sSUFBSS9CLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRStCLEtBQUssQ0FBQztBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL3J1cmFsLWhlYWx0aC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9Eb2NUeXBlUmVhZGVyLmpzP2JkOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpc05hbWV9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vL1RPRE86IGhhbmRsZSBjb21tZW50c1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZERvY1R5cGUoeG1sRGF0YSwgaSl7XG4gICAgXG4gICAgY29uc3QgZW50aXRpZXMgPSB7fTtcbiAgICBpZiggeG1sRGF0YVtpICsgM10gPT09ICdPJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNF0gPT09ICdDJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNV0gPT09ICdUJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNl0gPT09ICdZJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgN10gPT09ICdQJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgOF0gPT09ICdFJylcbiAgICB7ICAgIFxuICAgICAgICBpID0gaSs5O1xuICAgICAgICBsZXQgYW5nbGVCcmFja2V0c0NvdW50ID0gMTtcbiAgICAgICAgbGV0IGhhc0JvZHkgPSBmYWxzZSwgY29tbWVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZXhwID0gXCJcIjtcbiAgICAgICAgZm9yKDtpPHhtbERhdGEubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnICYmICFjb21tZW50KSB7IC8vRGV0ZXJtaW5lIHRoZSB0YWcgdHlwZVxuICAgICAgICAgICAgICAgIGlmKCBoYXNCb2R5ICYmIGhhc1NlcSh4bWxEYXRhLCBcIiFFTlRJVFlcIixpKSl7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNzsgXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnRpdHlOYW1lLCB2YWw7XG4gICAgICAgICAgICAgICAgICAgIFtlbnRpdHlOYW1lLCB2YWwsaV0gPSByZWFkRW50aXR5RXhwKHhtbERhdGEsaSsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodmFsLmluZGV4T2YoXCImXCIpID09PSAtMSkgLy9QYXJhbWV0ZXIgZW50aXRpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzWyBlbnRpdHlOYW1lIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVneCA6IFJlZ0V4cCggYCYke2VudGl0eU5hbWV9O2AsXCJnXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKCBoYXNCb2R5ICYmIGhhc1NlcSh4bWxEYXRhLCBcIiFFTEVNRU5UXCIsaSkpICB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gODsvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge2luZGV4fSA9IHJlYWRFbGVtZW50RXhwKHhtbERhdGEsaSsxKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKCBoYXNCb2R5ICYmIGhhc1NlcSh4bWxEYXRhLCBcIiFBVFRMSVNUXCIsaSkpe1xuICAgICAgICAgICAgICAgICAgICBpICs9IDg7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHtpbmRleH0gPSByZWFkQXR0bGlzdEV4cCh4bWxEYXRhLGkrMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZiggaGFzQm9keSAmJiBoYXNTZXEoeG1sRGF0YSwgXCIhTk9UQVRJT05cIixpKSkge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDk7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtpbmRleH0gPSByZWFkTm90YXRpb25FeHAoeG1sRGF0YSxpKzEpO1xuICAgICAgICAgICAgICAgICAgICBpID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoIGhhc1NlcSh4bWxEYXRhLCBcIiEtLVwiLGkpICkgY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRE9DVFlQRWApO1xuXG4gICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgZXhwID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJz4nKSB7IC8vUmVhZCB0YWcgY29udGVudFxuICAgICAgICAgICAgICAgIGlmKGNvbW1lbnQpe1xuICAgICAgICAgICAgICAgICAgICBpZiggeG1sRGF0YVtpIC0gMV0gPT09IFwiLVwiICYmIHhtbERhdGFbaSAtIDJdID09PSBcIi1cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlQnJhY2tldHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2UgaWYoIHhtbERhdGFbaV0gPT09ICdbJyl7XG4gICAgICAgICAgICAgICAgaGFzQm9keSA9IHRydWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBleHAgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihhbmdsZUJyYWNrZXRzQ291bnQgIT09IDApe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmNsb3NlZCBET0NUWVBFYCk7XG4gICAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFRhZyBpbnN0ZWFkIG9mIERPQ1RZUEVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtlbnRpdGllcywgaX07XG59XG5cbmNvbnN0IHNraXBXaGl0ZXNwYWNlID0gKGRhdGEsIGluZGV4KSA9PiB7XG4gICAgd2hpbGUgKGluZGV4IDwgZGF0YS5sZW5ndGggJiYgL1xccy8udGVzdChkYXRhW2luZGV4XSkpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuZnVuY3Rpb24gcmVhZEVudGl0eUV4cCh4bWxEYXRhLCBpKSB7ICAgIFxuICAgIC8vRXh0ZXJuYWwgZW50aXRpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAvLyAgICA8IUVOVElUWSBleHQgU1lTVEVNIFwiaHR0cDovL25vcm1hbC13ZWJzaXRlLmNvbVwiID5cblxuICAgIC8vUGFyYW1ldGVyIGVudGl0aWVzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgLy8gICAgPCFFTlRJVFkgZW50aXR5bmFtZSBcIiZhbm90aGVyRWxlbWVudDtcIj5cblxuICAgIC8vSW50ZXJuYWwgZW50aXRpZXMgYXJlIHN1cHBvcnRlZFxuICAgIC8vICAgIDwhRU5USVRZIGVudGl0eW5hbWUgXCJyZXBsYWNlbWVudCB0ZXh0XCI+XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgd2hpdGVzcGFjZSBhZnRlciA8IUVOVElUWVxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIFJlYWQgZW50aXR5IG5hbWVcbiAgICBsZXQgZW50aXR5TmFtZSA9IFwiXCI7XG4gICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiAhL1xccy8udGVzdCh4bWxEYXRhW2ldKSAmJiB4bWxEYXRhW2ldICE9PSAnXCInICYmIHhtbERhdGFbaV0gIT09IFwiJ1wiKSB7XG4gICAgICAgIGVudGl0eU5hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICB2YWxpZGF0ZUVudGl0eU5hbWUoZW50aXR5TmFtZSk7XG5cbiAgICAvLyBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgZW50aXR5IG5hbWVcbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAvLyBDaGVjayBmb3IgdW5zdXBwb3J0ZWQgY29uc3RydWN0cyAoZXh0ZXJuYWwgZW50aXRpZXMgb3IgcGFyYW1ldGVyIGVudGl0aWVzKVxuICAgIGlmICh4bWxEYXRhLnN1YnN0cmluZyhpLCBpICsgNikudG9VcHBlckNhc2UoKSA9PT0gXCJTWVNURU1cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9ZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gXCIlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGVudGl0aWVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgIC8vIFJlYWQgZW50aXR5IHZhbHVlIChpbnRlcm5hbCBlbnRpdHkpXG4gICAgbGV0IGVudGl0eVZhbHVlID0gXCJcIjtcbiAgICBbaSwgZW50aXR5VmFsdWVdID0gcmVhZElkZW50aWZpZXJWYWwoeG1sRGF0YSwgaSwgXCJlbnRpdHlcIik7XG4gICAgaS0tO1xuICAgIHJldHVybiBbZW50aXR5TmFtZSwgZW50aXR5VmFsdWUsIGkgXTtcbn1cblxuZnVuY3Rpb24gcmVhZE5vdGF0aW9uRXhwKHhtbERhdGEsIGkpIHtcbiAgICAvLyBTa2lwIGxlYWRpbmcgd2hpdGVzcGFjZSBhZnRlciA8IU5PVEFUSU9OXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gUmVhZCBub3RhdGlvbiBuYW1lXG4gICAgbGV0IG5vdGF0aW9uTmFtZSA9IFwiXCI7XG4gICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiAhL1xccy8udGVzdCh4bWxEYXRhW2ldKSkge1xuICAgICAgICBub3RhdGlvbk5hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICB2YWxpZGF0ZUVudGl0eU5hbWUobm90YXRpb25OYW1lKTtcblxuICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBub3RhdGlvbiBuYW1lXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gQ2hlY2sgaWRlbnRpZmllciB0eXBlIChTWVNURU0gb3IgUFVCTElDKVxuICAgIGNvbnN0IGlkZW50aWZpZXJUeXBlID0geG1sRGF0YS5zdWJzdHJpbmcoaSwgaSArIDYpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGlkZW50aWZpZXJUeXBlICE9PSBcIlNZU1RFTVwiICYmIGlkZW50aWZpZXJUeXBlICE9PSBcIlBVQkxJQ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgU1lTVEVNIG9yIFBVQkxJQywgZm91bmQgXCIke2lkZW50aWZpZXJUeXBlfVwiYCk7XG4gICAgfVxuICAgIGkgKz0gaWRlbnRpZmllclR5cGUubGVuZ3RoO1xuXG4gICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIGlkZW50aWZpZXIgdHlwZVxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIFJlYWQgcHVibGljIGlkZW50aWZpZXIgKGlmIFBVQkxJQylcbiAgICBsZXQgcHVibGljSWRlbnRpZmllciA9IG51bGw7XG4gICAgbGV0IHN5c3RlbUlkZW50aWZpZXIgPSBudWxsO1xuXG4gICAgaWYgKGlkZW50aWZpZXJUeXBlID09PSBcIlBVQkxJQ1wiKSB7XG4gICAgICAgIFtpLCBwdWJsaWNJZGVudGlmaWVyIF0gPSByZWFkSWRlbnRpZmllclZhbCh4bWxEYXRhLCBpLCBcInB1YmxpY0lkZW50aWZpZXJcIik7XG5cbiAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIHB1YmxpYyBpZGVudGlmaWVyXG4gICAgICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgICAgICAvLyBPcHRpb25hbGx5IHJlYWQgc3lzdGVtIGlkZW50aWZpZXJcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICdcIicgfHwgeG1sRGF0YVtpXSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIFtpLCBzeXN0ZW1JZGVudGlmaWVyIF0gPSByZWFkSWRlbnRpZmllclZhbCh4bWxEYXRhLCBpLFwic3lzdGVtSWRlbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaWRlbnRpZmllclR5cGUgPT09IFwiU1lTVEVNXCIpIHtcbiAgICAgICAgLy8gUmVhZCBzeXN0ZW0gaWRlbnRpZmllciAobWFuZGF0b3J5IGZvciBTWVNURU0pXG4gICAgICAgIFtpLCBzeXN0ZW1JZGVudGlmaWVyIF0gPSByZWFkSWRlbnRpZmllclZhbCh4bWxEYXRhLCBpLCBcInN5c3RlbUlkZW50aWZpZXJcIik7XG5cbiAgICAgICAgaWYgKCFzeXN0ZW1JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG1hbmRhdG9yeSBzeXN0ZW0gaWRlbnRpZmllciBmb3IgU1lTVEVNIG5vdGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7bm90YXRpb25OYW1lLCBwdWJsaWNJZGVudGlmaWVyLCBzeXN0ZW1JZGVudGlmaWVyLCBpbmRleDogLS1pfTtcbn1cblxuZnVuY3Rpb24gcmVhZElkZW50aWZpZXJWYWwoeG1sRGF0YSwgaSwgdHlwZSkge1xuICAgIGxldCBpZGVudGlmaWVyVmFsID0gXCJcIjtcbiAgICBjb25zdCBzdGFydENoYXIgPSB4bWxEYXRhW2ldO1xuICAgIGlmIChzdGFydENoYXIgIT09ICdcIicgJiYgc3RhcnRDaGFyICE9PSBcIidcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHF1b3RlZCBzdHJpbmcsIGZvdW5kIFwiJHtzdGFydENoYXJ9XCJgKTtcbiAgICB9XG4gICAgaSsrO1xuXG4gICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiB4bWxEYXRhW2ldICE9PSBzdGFydENoYXIpIHtcbiAgICAgICAgaWRlbnRpZmllclZhbCArPSB4bWxEYXRhW2ldO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHhtbERhdGFbaV0gIT09IHN0YXJ0Q2hhcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVudGVybWluYXRlZCAke3R5cGV9IHZhbHVlYCk7XG4gICAgfVxuICAgIGkrKztcbiAgICByZXR1cm4gW2ksIGlkZW50aWZpZXJWYWxdO1xufVxuXG5mdW5jdGlvbiByZWFkRWxlbWVudEV4cCh4bWxEYXRhLCBpKSB7XG4gICAgLy8gPCFFTEVNRU5UIGJyIEVNUFRZPlxuICAgIC8vIDwhRUxFTUVOVCBkaXYgQU5ZPlxuICAgIC8vIDwhRUxFTUVOVCB0aXRsZSAoI1BDREFUQSk+XG4gICAgLy8gPCFFTEVNRU5UIGJvb2sgKHRpdGxlLCBhdXRob3IrKT5cbiAgICAvLyA8IUVMRU1FTlQgbmFtZSAoY29udGVudC1tb2RlbCk+XG4gICAgXG4gICAgLy8gU2tpcCBsZWFkaW5nIHdoaXRlc3BhY2UgYWZ0ZXIgPCFFTEVNRU5UXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gUmVhZCBlbGVtZW50IG5hbWVcbiAgICBsZXQgZWxlbWVudE5hbWUgPSBcIlwiO1xuICAgIHdoaWxlIChpIDwgeG1sRGF0YS5sZW5ndGggJiYgIS9cXHMvLnRlc3QoeG1sRGF0YVtpXSkpIHtcbiAgICAgICAgZWxlbWVudE5hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGVsZW1lbnQgbmFtZVxuICAgIGlmICghdmFsaWRhdGVFbnRpdHlOYW1lKGVsZW1lbnROYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZWxlbWVudCBuYW1lOiBcIiR7ZWxlbWVudE5hbWV9XCJgKTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgZWxlbWVudCBuYW1lXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuICAgIGxldCBjb250ZW50TW9kZWwgPSBcIlwiO1xuICAgIC8vIEV4cGVjdCAnKCcgdG8gc3RhcnQgY29udGVudCBtb2RlbFxuICAgIGlmKHhtbERhdGFbaV0gPT09IFwiRVwiICYmIGhhc1NlcSh4bWxEYXRhLCBcIk1QVFlcIixpKSkgaSs9NDtcbiAgICBlbHNlIGlmKHhtbERhdGFbaV0gPT09IFwiQVwiICYmIGhhc1NlcSh4bWxEYXRhLCBcIk5ZXCIsaSkpIGkrPTI7XG4gICAgZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgaSsrOyAvLyBNb3ZlIHBhc3QgJygnXG5cbiAgICAgICAgLy8gUmVhZCBjb250ZW50IG1vZGVsXG4gICAgICAgIHdoaWxlIChpIDwgeG1sRGF0YS5sZW5ndGggJiYgeG1sRGF0YVtpXSAhPT0gXCIpXCIpIHtcbiAgICAgICAgICAgIGNvbnRlbnRNb2RlbCArPSB4bWxEYXRhW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4bWxEYXRhW2ldICE9PSBcIilcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW50ZXJtaW5hdGVkIGNvbnRlbnQgbW9kZWxcIik7XG4gICAgICAgIH1cblxuICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRWxlbWVudCBFeHByZXNzaW9uLCBmb3VuZCBcIiR7eG1sRGF0YVtpXX1cImApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50TmFtZSxcbiAgICAgICAgY29udGVudE1vZGVsOiBjb250ZW50TW9kZWwudHJpbSgpLFxuICAgICAgICBpbmRleDogaVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBdHRsaXN0RXhwKHhtbERhdGEsIGkpIHtcbiAgICAvLyBTa2lwIGxlYWRpbmcgd2hpdGVzcGFjZSBhZnRlciA8IUFUVExJU1RcbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAvLyBSZWFkIGVsZW1lbnQgbmFtZVxuICAgIGxldCBlbGVtZW50TmFtZSA9IFwiXCI7XG4gICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiAhL1xccy8udGVzdCh4bWxEYXRhW2ldKSkge1xuICAgICAgICBlbGVtZW50TmFtZSArPSB4bWxEYXRhW2ldO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgZWxlbWVudCBuYW1lXG4gICAgdmFsaWRhdGVFbnRpdHlOYW1lKGVsZW1lbnROYW1lKVxuXG4gICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIGVsZW1lbnQgbmFtZVxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIFJlYWQgYXR0cmlidXRlIG5hbWVcbiAgICBsZXQgYXR0cmlidXRlTmFtZSA9IFwiXCI7XG4gICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiAhL1xccy8udGVzdCh4bWxEYXRhW2ldKSkge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lICs9IHhtbERhdGFbaV07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBhdHRyaWJ1dGUgbmFtZVxuICAgIGlmICghdmFsaWRhdGVFbnRpdHlOYW1lKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogXCIke2F0dHJpYnV0ZU5hbWV9XCJgKTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgYXR0cmlidXRlIG5hbWVcbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAvLyBSZWFkIGF0dHJpYnV0ZSB0eXBlXG4gICAgbGV0IGF0dHJpYnV0ZVR5cGUgPSBcIlwiO1xuICAgIGlmICh4bWxEYXRhLnN1YnN0cmluZyhpLCBpICsgOCkudG9VcHBlckNhc2UoKSA9PT0gXCJOT1RBVElPTlwiKSB7XG4gICAgICAgIGF0dHJpYnV0ZVR5cGUgPSBcIk5PVEFUSU9OXCI7XG4gICAgICAgIGkgKz0gODsgLy8gTW92ZSBwYXN0IFwiTk9UQVRJT05cIlxuXG4gICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBcIk5PVEFUSU9OXCJcbiAgICAgICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgICAgIC8vIEV4cGVjdCAnKCcgdG8gc3RhcnQgdGhlIGxpc3Qgb2Ygbm90YXRpb25zXG4gICAgICAgIGlmICh4bWxEYXRhW2ldICE9PSBcIihcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnKCcsIGZvdW5kIFwiJHt4bWxEYXRhW2ldfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrOyAvLyBNb3ZlIHBhc3QgJygnXG5cbiAgICAgICAgLy8gUmVhZCB0aGUgbGlzdCBvZiBhbGxvd2VkIG5vdGF0aW9uc1xuICAgICAgICBsZXQgYWxsb3dlZE5vdGF0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmIHhtbERhdGFbaV0gIT09IFwiKVwiKSB7XG4gICAgICAgICAgICBsZXQgbm90YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiB4bWxEYXRhW2ldICE9PSBcInxcIiAmJiB4bWxEYXRhW2ldICE9PSBcIilcIikge1xuICAgICAgICAgICAgICAgIG5vdGF0aW9uICs9IHhtbERhdGFbaV07XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBub3RhdGlvbiBuYW1lXG4gICAgICAgICAgICBub3RhdGlvbiA9IG5vdGF0aW9uLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVFbnRpdHlOYW1lKG5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBub3RhdGlvbiBuYW1lOiBcIiR7bm90YXRpb259XCJgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWxsb3dlZE5vdGF0aW9ucy5wdXNoKG5vdGF0aW9uKTtcblxuICAgICAgICAgICAgLy8gU2tpcCAnfCcgc2VwYXJhdG9yIG9yIGV4aXQgbG9vcFxuICAgICAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgICAgICAgaSsrOyAvLyBNb3ZlIHBhc3QgJ3wnXG4gICAgICAgICAgICAgICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpOyAvLyBTa2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgYWZ0ZXIgJ3wnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeG1sRGF0YVtpXSAhPT0gXCIpXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVudGVybWluYXRlZCBsaXN0IG9mIG5vdGF0aW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7IC8vIE1vdmUgcGFzdCAnKSdcblxuICAgICAgICAvLyBTdG9yZSB0aGUgYWxsb3dlZCBub3RhdGlvbnMgYXMgcGFydCBvZiB0aGUgYXR0cmlidXRlIHR5cGVcbiAgICAgICAgYXR0cmlidXRlVHlwZSArPSBcIiAoXCIgKyBhbGxvd2VkTm90YXRpb25zLmpvaW4oXCJ8XCIpICsgXCIpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHNpbXBsZSB0eXBlcyAoZS5nLiwgQ0RBVEEsIElELCBJRFJFRiwgZXRjLilcbiAgICAgICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiAhL1xccy8udGVzdCh4bWxEYXRhW2ldKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlVHlwZSArPSB4bWxEYXRhW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgc2ltcGxlIGF0dHJpYnV0ZSB0eXBlXG4gICAgICAgIGNvbnN0IHZhbGlkVHlwZXMgPSBbXCJDREFUQVwiLCBcIklEXCIsIFwiSURSRUZcIiwgXCJJRFJFRlNcIiwgXCJFTlRJVFlcIiwgXCJFTlRJVElFU1wiLCBcIk5NVE9LRU5cIiwgXCJOTVRPS0VOU1wiXTtcbiAgICAgICAgaWYgKCF2YWxpZFR5cGVzLmluY2x1ZGVzKGF0dHJpYnV0ZVR5cGUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhdHRyaWJ1dGUgdHlwZTogXCIke2F0dHJpYnV0ZVR5cGV9XCJgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBhdHRyaWJ1dGUgdHlwZVxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIFJlYWQgZGVmYXVsdCB2YWx1ZVxuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBcIlwiO1xuICAgIGlmICh4bWxEYXRhLnN1YnN0cmluZyhpLCBpICsgOCkudG9VcHBlckNhc2UoKSA9PT0gXCIjUkVRVUlSRURcIikge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSBcIiNSRVFVSVJFRFwiO1xuICAgICAgICBpICs9IDg7XG4gICAgfSBlbHNlIGlmICh4bWxEYXRhLnN1YnN0cmluZyhpLCBpICsgNykudG9VcHBlckNhc2UoKSA9PT0gXCIjSU1QTElFRFwiKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IFwiI0lNUExJRURcIjtcbiAgICAgICAgaSArPSA3O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFtpLCBkZWZhdWx0VmFsdWVdID0gcmVhZElkZW50aWZpZXJWYWwoeG1sRGF0YSwgaSwgXCJBVFRMSVNUXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnROYW1lLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIGluZGV4OiBpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNTZXEoZGF0YSwgc2VxLGkpe1xuICAgIGZvcihsZXQgaj0wO2o8c2VxLmxlbmd0aDtqKyspe1xuICAgICAgICBpZihzZXFbal0hPT1kYXRhW2kraisxXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbnRpdHlOYW1lKG5hbWUpe1xuICAgIGlmIChpc05hbWUobmFtZSkpXG5cdHJldHVybiBuYW1lO1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVudGl0eSBuYW1lICR7bmFtZX1gKTtcbn1cbiJdLCJuYW1lcyI6WyJpc05hbWUiLCJyZWFkRG9jVHlwZSIsInhtbERhdGEiLCJpIiwiZW50aXRpZXMiLCJhbmdsZUJyYWNrZXRzQ291bnQiLCJoYXNCb2R5IiwiY29tbWVudCIsImV4cCIsImxlbmd0aCIsImhhc1NlcSIsImVudGl0eU5hbWUiLCJ2YWwiLCJyZWFkRW50aXR5RXhwIiwiaW5kZXhPZiIsInJlZ3giLCJSZWdFeHAiLCJpbmRleCIsInJlYWRFbGVtZW50RXhwIiwicmVhZE5vdGF0aW9uRXhwIiwiRXJyb3IiLCJza2lwV2hpdGVzcGFjZSIsImRhdGEiLCJ0ZXN0IiwidmFsaWRhdGVFbnRpdHlOYW1lIiwic3Vic3RyaW5nIiwidG9VcHBlckNhc2UiLCJlbnRpdHlWYWx1ZSIsInJlYWRJZGVudGlmaWVyVmFsIiwibm90YXRpb25OYW1lIiwiaWRlbnRpZmllclR5cGUiLCJwdWJsaWNJZGVudGlmaWVyIiwic3lzdGVtSWRlbnRpZmllciIsInR5cGUiLCJpZGVudGlmaWVyVmFsIiwic3RhcnRDaGFyIiwiZWxlbWVudE5hbWUiLCJjb250ZW50TW9kZWwiLCJ0cmltIiwicmVhZEF0dGxpc3RFeHAiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlVHlwZSIsImFsbG93ZWROb3RhdGlvbnMiLCJub3RhdGlvbiIsInB1c2giLCJqb2luIiwidmFsaWRUeXBlcyIsImluY2x1ZGVzIiwiZGVmYXVsdFZhbHVlIiwic2VxIiwiaiIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildOptions: () => (/* binding */ buildOptions),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions)\n/* harmony export */ });\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: \"@_\",\n    attributesGroupName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    removeNSPrefix: false,\n    allowBooleanAttributes: false,\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true,\n    cdataPropName: false,\n    numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n        return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n        return val;\n    },\n    stopNodes: [],\n    alwaysCreateTextNode: false,\n    isArray: ()=>false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs) {\n        return tagName;\n    },\n    // skipEmptyListItem: false\n    captureMetaData: false\n};\nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDTyxNQUFNQSxpQkFBaUI7SUFDMUJDLGVBQWU7SUFDZkMscUJBQXFCO0lBQ3JCQyxxQkFBcUI7SUFDckJDLGNBQWM7SUFDZEMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEJDLHdCQUF3QjtJQUN4Qiw0QkFBNEI7SUFDNUJDLGVBQWU7SUFDZkMscUJBQXFCO0lBQ3JCQyxZQUFZO0lBQ1pDLGVBQWU7SUFDZkMsb0JBQW9CO1FBQ2xCQyxLQUFLO1FBQ0xDLGNBQWM7UUFDZEMsV0FBVztJQUNiO0lBQ0FDLG1CQUFtQixTQUFTQyxPQUFPLEVBQUVDLEdBQUc7UUFDdEMsT0FBT0E7SUFDVDtJQUNBQyx5QkFBeUIsU0FBU0MsUUFBUSxFQUFFRixHQUFHO1FBQzdDLE9BQU9BO0lBQ1Q7SUFDQUcsV0FBVyxFQUFFO0lBQ2JDLHNCQUFzQjtJQUN0QkMsU0FBUyxJQUFNO0lBQ2ZDLGlCQUFpQjtJQUNqQkMsY0FBYyxFQUFFO0lBQ2hCQyxpQkFBaUI7SUFDakJDLGNBQWM7SUFDZEMsbUJBQW1CO0lBQ25CQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsd0JBQXdCO0lBQ3hCQyxXQUFXLFNBQVNmLE9BQU8sRUFBRWdCLEtBQUssRUFBRUMsS0FBSztRQUN2QyxPQUFPakI7SUFDVDtJQUNBLDJCQUEyQjtJQUMzQmtCLGlCQUFpQjtBQUNyQixFQUFFO0FBRUssTUFBTUMsZUFBZSxTQUFTQyxPQUFPO0lBQ3hDLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUd2QyxnQkFBZ0JxQztBQUM3QyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnVyYWwtaGVhbHRoLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL09wdGlvbnNCdWlsZGVyLmpzP2JiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcHJlc2VydmVPcmRlcjogZmFsc2UsXG4gICAgYXR0cmlidXRlTmFtZVByZWZpeDogJ0BfJyxcbiAgICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBmYWxzZSxcbiAgICB0ZXh0Tm9kZU5hbWU6ICcjdGV4dCcsXG4gICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgICByZW1vdmVOU1ByZWZpeDogZmFsc2UsIC8vIHJlbW92ZSBOUyBmcm9tIHRhZyBuYW1lIG9yIGF0dHJpYnV0ZSBuYW1lIGlmIHRydWVcbiAgICBhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzOiBmYWxzZSwgLy9hIHRhZyBjYW4gaGF2ZSBhdHRyaWJ1dGVzIHdpdGhvdXQgYW55IHZhbHVlXG4gICAgLy9pZ25vcmVSb290RWxlbWVudCA6IGZhbHNlLFxuICAgIHBhcnNlVGFnVmFsdWU6IHRydWUsXG4gICAgcGFyc2VBdHRyaWJ1dGVWYWx1ZTogZmFsc2UsXG4gICAgdHJpbVZhbHVlczogdHJ1ZSwgLy9UcmltIHN0cmluZyB2YWx1ZXMgb2YgdGFnIGFuZCBhdHRyaWJ1dGVzXG4gICAgY2RhdGFQcm9wTmFtZTogZmFsc2UsXG4gICAgbnVtYmVyUGFyc2VPcHRpb25zOiB7XG4gICAgICBoZXg6IHRydWUsXG4gICAgICBsZWFkaW5nWmVyb3M6IHRydWUsXG4gICAgICBlTm90YXRpb246IHRydWVcbiAgICB9LFxuICAgIHRhZ1ZhbHVlUHJvY2Vzc29yOiBmdW5jdGlvbih0YWdOYW1lLCB2YWwpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcbiAgICBhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24oYXR0ck5hbWUsIHZhbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuICAgIHN0b3BOb2RlczogW10sIC8vbmVzdGVkIHRhZ3Mgd2lsbCBub3QgYmUgcGFyc2VkIGV2ZW4gZm9yIGVycm9yc1xuICAgIGFsd2F5c0NyZWF0ZVRleHROb2RlOiBmYWxzZSxcbiAgICBpc0FycmF5OiAoKSA9PiBmYWxzZSxcbiAgICBjb21tZW50UHJvcE5hbWU6IGZhbHNlLFxuICAgIHVucGFpcmVkVGFnczogW10sXG4gICAgcHJvY2Vzc0VudGl0aWVzOiB0cnVlLFxuICAgIGh0bWxFbnRpdGllczogZmFsc2UsXG4gICAgaWdub3JlRGVjbGFyYXRpb246IGZhbHNlLFxuICAgIGlnbm9yZVBpVGFnczogZmFsc2UsXG4gICAgdHJhbnNmb3JtVGFnTmFtZTogZmFsc2UsXG4gICAgdHJhbnNmb3JtQXR0cmlidXRlTmFtZTogZmFsc2UsXG4gICAgdXBkYXRlVGFnOiBmdW5jdGlvbih0YWdOYW1lLCBqUGF0aCwgYXR0cnMpe1xuICAgICAgcmV0dXJuIHRhZ05hbWVcbiAgICB9LFxuICAgIC8vIHNraXBFbXB0eUxpc3RJdGVtOiBmYWxzZVxuICAgIGNhcHR1cmVNZXRhRGF0YTogZmFsc2UsXG59O1xuICAgXG5leHBvcnQgY29uc3QgYnVpbGRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG59O1xuIl0sIm5hbWVzIjpbImRlZmF1bHRPcHRpb25zIiwicHJlc2VydmVPcmRlciIsImF0dHJpYnV0ZU5hbWVQcmVmaXgiLCJhdHRyaWJ1dGVzR3JvdXBOYW1lIiwidGV4dE5vZGVOYW1lIiwiaWdub3JlQXR0cmlidXRlcyIsInJlbW92ZU5TUHJlZml4IiwiYWxsb3dCb29sZWFuQXR0cmlidXRlcyIsInBhcnNlVGFnVmFsdWUiLCJwYXJzZUF0dHJpYnV0ZVZhbHVlIiwidHJpbVZhbHVlcyIsImNkYXRhUHJvcE5hbWUiLCJudW1iZXJQYXJzZU9wdGlvbnMiLCJoZXgiLCJsZWFkaW5nWmVyb3MiLCJlTm90YXRpb24iLCJ0YWdWYWx1ZVByb2Nlc3NvciIsInRhZ05hbWUiLCJ2YWwiLCJhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvciIsImF0dHJOYW1lIiwic3RvcE5vZGVzIiwiYWx3YXlzQ3JlYXRlVGV4dE5vZGUiLCJpc0FycmF5IiwiY29tbWVudFByb3BOYW1lIiwidW5wYWlyZWRUYWdzIiwicHJvY2Vzc0VudGl0aWVzIiwiaHRtbEVudGl0aWVzIiwiaWdub3JlRGVjbGFyYXRpb24iLCJpZ25vcmVQaVRhZ3MiLCJ0cmFuc2Zvcm1UYWdOYW1lIiwidHJhbnNmb3JtQXR0cmlidXRlTmFtZSIsInVwZGF0ZVRhZyIsImpQYXRoIiwiYXR0cnMiLCJjYXB0dXJlTWV0YURhdGEiLCJidWlsZE9wdGlvbnMiLCJvcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OrderedObjParser)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ \"(rsc)/./node_modules/fast-xml-parser/src/util.js\");\n/* harmony import */ var _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xmlNode.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\n/* harmony import */ var _DocTypeReader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DocTypeReader.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\");\n/* harmony import */ var strnum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strnum */ \"(rsc)/./node_modules/strnum/strnum.js\");\n/* harmony import */ var _ignoreAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ignoreAttributes.js */ \"(rsc)/./node_modules/fast-xml-parser/src/ignoreAttributes.js\");\n\n///@ts-check\n\n\n\n\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\nclass OrderedObjParser {\n    constructor(options){\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n            \"apos\": {\n                regex: /&(apos|#39|#x27);/g,\n                val: \"'\"\n            },\n            \"gt\": {\n                regex: /&(gt|#62|#x3E);/g,\n                val: \">\"\n            },\n            \"lt\": {\n                regex: /&(lt|#60|#x3C);/g,\n                val: \"<\"\n            },\n            \"quot\": {\n                regex: /&(quot|#34|#x22);/g,\n                val: '\"'\n            }\n        };\n        this.ampEntity = {\n            regex: /&(amp|#38|#x26);/g,\n            val: \"&\"\n        };\n        this.htmlEntities = {\n            \"space\": {\n                regex: /&(nbsp|#160);/g,\n                val: \" \"\n            },\n            // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n            // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n            // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n            // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n            // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n            \"cent\": {\n                regex: /&(cent|#162);/g,\n                val: \"\\xa2\"\n            },\n            \"pound\": {\n                regex: /&(pound|#163);/g,\n                val: \"\\xa3\"\n            },\n            \"yen\": {\n                regex: /&(yen|#165);/g,\n                val: \"\\xa5\"\n            },\n            \"euro\": {\n                regex: /&(euro|#8364);/g,\n                val: \"\"\n            },\n            \"copyright\": {\n                regex: /&(copy|#169);/g,\n                val: \"\\xa9\"\n            },\n            \"reg\": {\n                regex: /&(reg|#174);/g,\n                val: \"\\xae\"\n            },\n            \"inr\": {\n                regex: /&(inr|#8377);/g,\n                val: \"\"\n            },\n            \"num_dec\": {\n                regex: /&#([0-9]{1,7});/g,\n                val: (_, str)=>String.fromCodePoint(Number.parseInt(str, 10))\n            },\n            \"num_hex\": {\n                regex: /&#x([0-9a-fA-F]{1,6});/g,\n                val: (_, str)=>String.fromCodePoint(Number.parseInt(str, 16))\n            }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n        this.ignoreAttributesFn = (0,_ignoreAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.options.ignoreAttributes);\n    }\n}\nfunction addExternalEntities(externalEntities) {\n    const entKeys = Object.keys(externalEntities);\n    for(let i = 0; i < entKeys.length; i++){\n        const ent = entKeys[i];\n        this.lastEntities[ent] = {\n            regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n            val: externalEntities[ent]\n        };\n    }\n}\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */ function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n    if (val !== undefined) {\n        if (this.options.trimValues && !dontTrim) {\n            val = val.trim();\n        }\n        if (val.length > 0) {\n            if (!escapeEntities) val = this.replaceEntitiesValue(val);\n            const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n            if (newval === null || newval === undefined) {\n                //don't parse\n                return val;\n            } else if (typeof newval !== typeof val || newval !== val) {\n                //overwrite\n                return newval;\n            } else if (this.options.trimValues) {\n                return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n            } else {\n                const trimmedVal = val.trim();\n                if (trimmedVal === val) {\n                    return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n                } else {\n                    return val;\n                }\n            }\n        }\n    }\n}\nfunction resolveNameSpace(tagname) {\n    if (this.options.removeNSPrefix) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\", \"gm\");\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n    if (this.options.ignoreAttributes !== true && typeof attrStr === \"string\") {\n        // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n        //attrStr = attrStr || attrStr.trim();\n        const matches = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getAllMatches)(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for(let i = 0; i < len; i++){\n            const attrName = this.resolveNameSpace(matches[i][1]);\n            if (this.ignoreAttributesFn(attrName, jPath)) {\n                continue;\n            }\n            let oldVal = matches[i][4];\n            let aName = this.options.attributeNamePrefix + attrName;\n            if (attrName.length) {\n                if (this.options.transformAttributeName) {\n                    aName = this.options.transformAttributeName(aName);\n                }\n                if (aName === \"__proto__\") aName = \"#__proto__\";\n                if (oldVal !== undefined) {\n                    if (this.options.trimValues) {\n                        oldVal = oldVal.trim();\n                    }\n                    oldVal = this.replaceEntitiesValue(oldVal);\n                    const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n                    if (newVal === null || newVal === undefined) {\n                        //don't parse\n                        attrs[aName] = oldVal;\n                    } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n                        //overwrite\n                        attrs[aName] = newVal;\n                    } else {\n                        //parse\n                        attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n                    }\n                } else if (this.options.allowBooleanAttributes) {\n                    attrs[aName] = true;\n                }\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (this.options.attributesGroupName) {\n            const attrCollection = {};\n            attrCollection[this.options.attributesGroupName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\nconst parseXml = function(xmlData) {\n    xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n    const xmlObj = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"!xml\");\n    let currentNode = xmlObj;\n    let textData = \"\";\n    let jPath = \"\";\n    for(let i = 0; i < xmlData.length; i++){\n        const ch = xmlData[i];\n        if (ch === \"<\") {\n            // const nextIndex = i+1;\n            // const _2ndChar = xmlData[nextIndex];\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n                let tagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (this.options.removeNSPrefix) {\n                    const colonIndex = tagName.indexOf(\":\");\n                    if (colonIndex !== -1) {\n                        tagName = tagName.substr(colonIndex + 1);\n                    }\n                }\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                if (currentNode) {\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                }\n                //check if last tag of nested tag was unpaired tag\n                const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n                if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n                    throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n                }\n                let propIndex = 0;\n                if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n                    propIndex = jPath.lastIndexOf(\".\", jPath.lastIndexOf(\".\") - 1);\n                    this.tagsNodeStack.pop();\n                } else {\n                    propIndex = jPath.lastIndexOf(\".\");\n                }\n                jPath = jPath.substring(0, propIndex);\n                currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope\n                textData = \"\";\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                let tagData = readTagExp(xmlData, i, false, \"?>\");\n                if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n                    const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagData.tagName);\n                    childNode.add(this.options.textNodeName, \"\");\n                    if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n                    }\n                    this.addChild(currentNode, childNode, jPath, i);\n                }\n                i = tagData.closeIndex + 1;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n                if (this.options.commentPropName) {\n                    const comment = xmlData.substring(i + 4, endIndex - 2);\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                    currentNode.add(this.options.commentPropName, [\n                        {\n                            [this.options.textNodeName]: comment\n                        }\n                    ]);\n                }\n                i = endIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"!D\") {\n                const result = (0,_DocTypeReader_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(xmlData, i);\n                this.docTypeEntities = result.entities;\n                i = result.i;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n                const tagExp = xmlData.substring(i + 9, closeIndex);\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n                if (val == undefined) val = \"\";\n                //cdata should be set even if it is 0 length string\n                if (this.options.cdataPropName) {\n                    currentNode.add(this.options.cdataPropName, [\n                        {\n                            [this.options.textNodeName]: tagExp\n                        }\n                    ]);\n                } else {\n                    currentNode.add(this.options.textNodeName, val);\n                }\n                i = closeIndex + 2;\n            } else {\n                let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n                let tagName = result.tagName;\n                const rawTagName = result.rawTagName;\n                let tagExp = result.tagExp;\n                let attrExpPresent = result.attrExpPresent;\n                let closeIndex = result.closeIndex;\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                //save text as child node\n                if (currentNode && textData) {\n                    if (currentNode.tagname !== \"!xml\") {\n                        //when nested tag is found\n                        textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n                    }\n                }\n                //check if last tag was unpaired tag\n                const lastTag = currentNode;\n                if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n                    currentNode = this.tagsNodeStack.pop();\n                    jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n                }\n                if (tagName !== xmlObj.tagname) {\n                    jPath += jPath ? \".\" + tagName : tagName;\n                }\n                const startIndex = i;\n                if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n                    let tagContent = \"\";\n                    //self-closing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        if (tagName[tagName.length - 1] === \"/\") {\n                            tagName = tagName.substr(0, tagName.length - 1);\n                            jPath = jPath.substr(0, jPath.length - 1);\n                            tagExp = tagName;\n                        } else {\n                            tagExp = tagExp.substr(0, tagExp.length - 1);\n                        }\n                        i = result.closeIndex;\n                    } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                        i = result.closeIndex;\n                    } else {\n                        //read until closing tag is found\n                        const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n                        if (!result) throw new Error(`Unexpected end of ${rawTagName}`);\n                        i = result.i;\n                        tagContent = result.tagContent;\n                    }\n                    const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagName);\n                    if (tagName !== tagExp && attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                    }\n                    if (tagContent) {\n                        tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n                    }\n                    jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    childNode.add(this.options.textNodeName, tagContent);\n                    this.addChild(currentNode, childNode, jPath, startIndex);\n                } else {\n                    //selfClosing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        if (tagName[tagName.length - 1] === \"/\") {\n                            tagName = tagName.substr(0, tagName.length - 1);\n                            jPath = jPath.substr(0, jPath.length - 1);\n                            tagExp = tagName;\n                        } else {\n                            tagExp = tagExp.substr(0, tagExp.length - 1);\n                        }\n                        if (this.options.transformTagName) {\n                            tagName = this.options.transformTagName(tagName);\n                        }\n                        const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagName);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath, startIndex);\n                        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    } else {\n                        const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagName);\n                        this.tagsNodeStack.push(currentNode);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath, startIndex);\n                        currentNode = childNode;\n                    }\n                    textData = \"\";\n                    i = closeIndex;\n                }\n            }\n        } else {\n            textData += xmlData[i];\n        }\n    }\n    return xmlObj.child;\n};\nfunction addChild(currentNode, childNode, jPath, startIndex) {\n    // unset startIndex if not requested\n    if (!this.options.captureMetaData) startIndex = undefined;\n    const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n    if (result === false) {} else if (typeof result === \"string\") {\n        childNode.tagname = result;\n        currentNode.addChild(childNode, startIndex);\n    } else {\n        currentNode.addChild(childNode, startIndex);\n    }\n}\nconst replaceEntitiesValue = function(val) {\n    if (this.options.processEntities) {\n        for(let entityName in this.docTypeEntities){\n            const entity = this.docTypeEntities[entityName];\n            val = val.replace(entity.regx, entity.val);\n        }\n        for(let entityName in this.lastEntities){\n            const entity = this.lastEntities[entityName];\n            val = val.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n            for(let entityName in this.htmlEntities){\n                const entity = this.htmlEntities[entityName];\n                val = val.replace(entity.regex, entity.val);\n            }\n        }\n        val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n    }\n    return val;\n};\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n    if (textData) {\n        if (isLeafNode === undefined) isLeafNode = currentNode.child.length === 0;\n        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n        if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n        textData = \"\";\n    }\n    return textData;\n}\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */ function isItStopNode(stopNodes, jPath, currentTagName) {\n    const allNodesExp = \"*.\" + currentTagName;\n    for(const stopNodePath in stopNodes){\n        const stopNodeExp = stopNodes[stopNodePath];\n        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n    }\n    return false;\n}\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */ function tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n    let attrBoundary;\n    let tagExp = \"\";\n    for(let index = i; index < xmlData.length; index++){\n        let ch = xmlData[index];\n        if (attrBoundary) {\n            if (ch === attrBoundary) attrBoundary = \"\"; //reset\n        } else if (ch === '\"' || ch === \"'\") {\n            attrBoundary = ch;\n        } else if (ch === closingChar[0]) {\n            if (closingChar[1]) {\n                if (xmlData[index + 1] === closingChar[1]) {\n                    return {\n                        data: tagExp,\n                        index: index\n                    };\n                }\n            } else {\n                return {\n                    data: tagExp,\n                    index: index\n                };\n            }\n        } else if (ch === \"\t\") {\n            ch = \" \";\n        }\n        tagExp += ch;\n    }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n    const closingIndex = xmlData.indexOf(str, i);\n    if (closingIndex === -1) {\n        throw new Error(errMsg);\n    } else {\n        return closingIndex + str.length - 1;\n    }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n    if (!result) return;\n    let tagExp = result.data;\n    const closeIndex = result.index;\n    const separatorIndex = tagExp.search(/\\s/);\n    let tagName = tagExp;\n    let attrExpPresent = true;\n    if (separatorIndex !== -1) {\n        tagName = tagExp.substring(0, separatorIndex);\n        tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n    }\n    const rawTagName = tagName;\n    if (removeNSPrefix) {\n        const colonIndex = tagName.indexOf(\":\");\n        if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n        }\n    }\n    return {\n        tagName: tagName,\n        tagExp: tagExp,\n        closeIndex: closeIndex,\n        attrExpPresent: attrExpPresent,\n        rawTagName: rawTagName\n    };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */ function readStopNodeData(xmlData, tagName, i) {\n    const startIndex = i;\n    // Starting at 1 since we already have an open tag\n    let openTagCount = 1;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\") {\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n                let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (closeTagName === tagName) {\n                    openTagCount--;\n                    if (openTagCount === 0) {\n                        return {\n                            tagContent: xmlData.substring(startIndex, i),\n                            i: closeIndex\n                        };\n                    }\n                }\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n                i = closeIndex;\n            } else {\n                const tagData = readTagExp(xmlData, i, \">\");\n                if (tagData) {\n                    const openTagName = tagData && tagData.tagName;\n                    if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n                        openTagCount++;\n                    }\n                    i = tagData.closeIndex;\n                }\n            }\n        }\n    } //end for loop\n}\nfunction parseValue(val, shouldParse, options) {\n    if (shouldParse && typeof val === \"string\") {\n        //console.log(options)\n        const newval = val.trim();\n        if (newval === \"true\") return true;\n        else if (newval === \"false\") return false;\n        else return (0,strnum__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(val, options);\n    } else {\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isExist)(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVk7QUFFc0M7QUFDZjtBQUNVO0FBQ2Y7QUFDNkI7QUFFM0QsZUFBZTtBQUNmLDRGQUE0RjtBQUM1Rix3Q0FBd0M7QUFFeEMsOEZBQThGO0FBQzlGLG9IQUFvSDtBQUVyRyxNQUFNTTtJQUNuQkMsWUFBWUMsT0FBTyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsQ0FBQztRQUN4QixJQUFJLENBQUNDLFlBQVksR0FBRztZQUNsQixRQUFTO2dCQUFFQyxPQUFPO2dCQUFzQkMsS0FBTTtZQUFHO1lBQ2pELE1BQU87Z0JBQUVELE9BQU87Z0JBQW9CQyxLQUFNO1lBQUc7WUFDN0MsTUFBTztnQkFBRUQsT0FBTztnQkFBb0JDLEtBQU07WUFBRztZQUM3QyxRQUFTO2dCQUFFRCxPQUFPO2dCQUFzQkMsS0FBTTtZQUFJO1FBQ3BEO1FBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUc7WUFBRUYsT0FBTztZQUFxQkMsS0FBTTtRQUFHO1FBQ3hELElBQUksQ0FBQ0UsWUFBWSxHQUFHO1lBQ2xCLFNBQVM7Z0JBQUVILE9BQU87Z0JBQWtCQyxLQUFLO1lBQUk7WUFDN0MsNkNBQTZDO1lBQzdDLDZDQUE2QztZQUM3QywrQ0FBK0M7WUFDL0Msa0RBQWtEO1lBQ2xELGlEQUFpRDtZQUNqRCxRQUFTO2dCQUFFRCxPQUFPO2dCQUFrQkMsS0FBSztZQUFJO1lBQzdDLFNBQVU7Z0JBQUVELE9BQU87Z0JBQW1CQyxLQUFLO1lBQUk7WUFDL0MsT0FBUTtnQkFBRUQsT0FBTztnQkFBaUJDLEtBQUs7WUFBSTtZQUMzQyxRQUFTO2dCQUFFRCxPQUFP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STJELFNBQVM7b0JBQ1gsTUFBTTRDLGNBQWM1QyxXQUFXQSxRQUFRdkQsT0FBTztvQkFDOUMsSUFBSW1HLGdCQUFnQm5HLFdBQVd1RCxRQUFRTyxNQUFNLENBQUNQLFFBQVFPLE1BQU0sQ0FBQ2pFLE1BQU0sR0FBQyxFQUFFLEtBQUssS0FBSzt3QkFDOUVvRztvQkFDRjtvQkFDQXJHLElBQUUyRCxRQUFRYixVQUFVO2dCQUN0QjtZQUNGO1FBQ0Y7SUFDSixFQUFDLGNBQWM7QUFDakI7QUFFQSxTQUFTL0IsV0FBV3hDLEdBQUcsRUFBRWlJLFdBQVcsRUFBRXZJLE9BQU87SUFDM0MsSUFBSXVJLGVBQWUsT0FBT2pJLFFBQVEsVUFBVTtRQUMxQyxzQkFBc0I7UUFDdEIsTUFBTXNDLFNBQVN0QyxJQUFJcUMsSUFBSTtRQUN2QixJQUFHQyxXQUFXLFFBQVMsT0FBTzthQUN6QixJQUFHQSxXQUFXLFNBQVUsT0FBTzthQUMvQixPQUFPaEQsa0RBQVFBLENBQUNVLEtBQUtOO0lBQzVCLE9BQU87UUFDTCxJQUFJUCxpREFBT0EsQ0FBQ2EsTUFBTTtZQUNoQixPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPO1FBQ1Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnVyYWwtaGVhbHRoLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL09yZGVyZWRPYmpQYXJzZXIuanM/MDNhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLy9AdHMtY2hlY2tcblxuaW1wb3J0IHtnZXRBbGxNYXRjaGVzLCBpc0V4aXN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB4bWxOb2RlIGZyb20gJy4veG1sTm9kZS5qcyc7XG5pbXBvcnQgcmVhZERvY1R5cGUgZnJvbSAnLi9Eb2NUeXBlUmVhZGVyLmpzJztcbmltcG9ydCB0b051bWJlciBmcm9tIFwic3RybnVtXCI7XG5pbXBvcnQgZ2V0SWdub3JlQXR0cmlidXRlc0ZuIGZyb20gXCIuLi9pZ25vcmVBdHRyaWJ1dGVzLmpzXCI7XG5cbi8vIGNvbnN0IHJlZ3ggPVxuLy8gICAnPCgoIVxcXFxbQ0RBVEFcXFxcWyhbXFxcXHNcXFxcU10qPykoXV0+KSl8KChOQU1FOik/KE5BTUUpKShbXj5dKik+fCgoXFxcXC8pKE5BTUUpXFxcXHMqPikpKFtePF0qKSdcbi8vICAgLnJlcGxhY2UoL05BTUUvZywgdXRpbC5uYW1lUmVnZXhwKTtcblxuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvP1tcXFxcdzpcXFxcLVxcLl9dKykoW14+XSopPihcXFxccypcIitjZGF0YVJlZ3grXCIpKihbXjxdKyk/XCIsXCJnXCIpO1xuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvPykoKFxcXFx3KjopPyhbXFxcXHc6XFxcXC1cXC5fXSspKShbXj5dKik+KFtePF0qKShcIitjZGF0YVJlZ3grXCIoW148XSopKSooW148XSspP1wiLFwiZ1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3JkZXJlZE9ialBhcnNlcntcbiAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLnRhZ3NOb2RlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmRvY1R5cGVFbnRpdGllcyA9IHt9O1xuICAgIHRoaXMubGFzdEVudGl0aWVzID0ge1xuICAgICAgXCJhcG9zXCIgOiB7IHJlZ2V4OiAvJihhcG9zfCMzOXwjeDI3KTsvZywgdmFsIDogXCInXCJ9LFxuICAgICAgXCJndFwiIDogeyByZWdleDogLyYoZ3R8IzYyfCN4M0UpOy9nLCB2YWwgOiBcIj5cIn0sXG4gICAgICBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjB8I3gzQyk7L2csIHZhbCA6IFwiPFwifSxcbiAgICAgIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzR8I3gyMik7L2csIHZhbCA6IFwiXFxcIlwifSxcbiAgICB9O1xuICAgIHRoaXMuYW1wRW50aXR5ID0geyByZWdleDogLyYoYW1wfCMzOHwjeDI2KTsvZywgdmFsIDogXCImXCJ9O1xuICAgIHRoaXMuaHRtbEVudGl0aWVzID0ge1xuICAgICAgXCJzcGFjZVwiOiB7IHJlZ2V4OiAvJihuYnNwfCMxNjApOy9nLCB2YWw6IFwiIFwiIH0sXG4gICAgICAvLyBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjApOy9nLCB2YWw6IFwiPFwiIH0sXG4gICAgICAvLyBcImd0XCIgOiB7IHJlZ2V4OiAvJihndHwjNjIpOy9nLCB2YWw6IFwiPlwiIH0sXG4gICAgICAvLyBcImFtcFwiIDogeyByZWdleDogLyYoYW1wfCMzOCk7L2csIHZhbDogXCImXCIgfSxcbiAgICAgIC8vIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzQpOy9nLCB2YWw6IFwiXFxcIlwiIH0sXG4gICAgICAvLyBcImFwb3NcIiA6IHsgcmVnZXg6IC8mKGFwb3N8IzM5KTsvZywgdmFsOiBcIidcIiB9LFxuICAgICAgXCJjZW50XCIgOiB7IHJlZ2V4OiAvJihjZW50fCMxNjIpOy9nLCB2YWw6IFwiwqJcIiB9LFxuICAgICAgXCJwb3VuZFwiIDogeyByZWdleDogLyYocG91bmR8IzE2Myk7L2csIHZhbDogXCLCo1wiIH0sXG4gICAgICBcInllblwiIDogeyByZWdleDogLyYoeWVufCMxNjUpOy9nLCB2YWw6IFwiwqVcIiB9LFxuICAgICAgXCJldXJvXCIgOiB7IHJlZ2V4OiAvJihldXJvfCM4MzY0KTsvZywgdmFsOiBcIuKCrFwiIH0sXG4gICAgICBcImNvcHlyaWdodFwiIDogeyByZWdleDogLyYoY29weXwjMTY5KTsvZywgdmFsOiBcIsKpXCIgfSxcbiAgICAgIFwicmVnXCIgOiB7IHJlZ2V4OiAvJihyZWd8IzE3NCk7L2csIHZhbDogXCLCrlwiIH0sXG4gICAgICBcImluclwiIDogeyByZWdleDogLyYoaW5yfCM4Mzc3KTsvZywgdmFsOiBcIuKCuVwiIH0sXG4gICAgICBcIm51bV9kZWNcIjogeyByZWdleDogLyYjKFswLTldezEsN30pOy9nLCB2YWwgOiAoXywgc3RyKSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludChOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCkpIH0sXG4gICAgICBcIm51bV9oZXhcIjogeyByZWdleDogLyYjeChbMC05YS1mQS1GXXsxLDZ9KTsvZywgdmFsIDogKF8sIHN0cikgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoTnVtYmVyLnBhcnNlSW50KHN0ciwgMTYpKSB9LFxuICAgIH07XG4gICAgdGhpcy5hZGRFeHRlcm5hbEVudGl0aWVzID0gYWRkRXh0ZXJuYWxFbnRpdGllcztcbiAgICB0aGlzLnBhcnNlWG1sID0gcGFyc2VYbWw7XG4gICAgdGhpcy5wYXJzZVRleHREYXRhID0gcGFyc2VUZXh0RGF0YTtcbiAgICB0aGlzLnJlc29sdmVOYW1lU3BhY2UgPSByZXNvbHZlTmFtZVNwYWNlO1xuICAgIHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwID0gYnVpbGRBdHRyaWJ1dGVzTWFwO1xuICAgIHRoaXMuaXNJdFN0b3BOb2RlID0gaXNJdFN0b3BOb2RlO1xuICAgIHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUgPSByZXBsYWNlRW50aXRpZXNWYWx1ZTtcbiAgICB0aGlzLnJlYWRTdG9wTm9kZURhdGEgPSByZWFkU3RvcE5vZGVEYXRhO1xuICAgIHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyA9IHNhdmVUZXh0VG9QYXJlbnRUYWc7XG4gICAgdGhpcy5hZGRDaGlsZCA9IGFkZENoaWxkO1xuICAgIHRoaXMuaWdub3JlQXR0cmlidXRlc0ZuID0gZ2V0SWdub3JlQXR0cmlidXRlc0ZuKHRoaXMub3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzKVxuICB9XG5cbn1cblxuZnVuY3Rpb24gYWRkRXh0ZXJuYWxFbnRpdGllcyhleHRlcm5hbEVudGl0aWVzKXtcbiAgY29uc3QgZW50S2V5cyA9IE9iamVjdC5rZXlzKGV4dGVybmFsRW50aXRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVudEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbnQgPSBlbnRLZXlzW2ldO1xuICAgIHRoaXMubGFzdEVudGl0aWVzW2VudF0gPSB7XG4gICAgICAgcmVnZXg6IG5ldyBSZWdFeHAoXCImXCIrZW50K1wiO1wiLFwiZ1wiKSxcbiAgICAgICB2YWwgOiBleHRlcm5hbEVudGl0aWVzW2VudF1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGpQYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRUcmltXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0F0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFmTm9kZVxuICogQHBhcmFtIHtib29sZWFufSBlc2NhcGVFbnRpdGllc1xuICovXG5mdW5jdGlvbiBwYXJzZVRleHREYXRhKHZhbCwgdGFnTmFtZSwgalBhdGgsIGRvbnRUcmltLCBoYXNBdHRyaWJ1dGVzLCBpc0xlYWZOb2RlLCBlc2NhcGVFbnRpdGllcykge1xuICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRyaW1WYWx1ZXMgJiYgIWRvbnRUcmltKSB7XG4gICAgICB2YWwgPSB2YWwudHJpbSgpO1xuICAgIH1cbiAgICBpZih2YWwubGVuZ3RoID4gMCl7XG4gICAgICBpZighZXNjYXBlRW50aXRpZXMpIHZhbCA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUodmFsKTtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3dmFsID0gdGhpcy5vcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKHRhZ05hbWUsIHZhbCwgalBhdGgsIGhhc0F0dHJpYnV0ZXMsIGlzTGVhZk5vZGUpO1xuICAgICAgaWYobmV3dmFsID09PSBudWxsIHx8IG5ld3ZhbCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgLy9kb24ndCBwYXJzZVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfWVsc2UgaWYodHlwZW9mIG5ld3ZhbCAhPT0gdHlwZW9mIHZhbCB8fCBuZXd2YWwgIT09IHZhbCl7XG4gICAgICAgIC8vb3ZlcndyaXRlXG4gICAgICAgIHJldHVybiBuZXd2YWw7XG4gICAgICB9ZWxzZSBpZih0aGlzLm9wdGlvbnMudHJpbVZhbHVlcyl7XG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHZhbCwgdGhpcy5vcHRpb25zLnBhcnNlVGFnVmFsdWUsIHRoaXMub3B0aW9ucy5udW1iZXJQYXJzZU9wdGlvbnMpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGNvbnN0IHRyaW1tZWRWYWwgPSB2YWwudHJpbSgpO1xuICAgICAgICBpZih0cmltbWVkVmFsID09PSB2YWwpe1xuICAgICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHZhbCwgdGhpcy5vcHRpb25zLnBhcnNlVGFnVmFsdWUsIHRoaXMub3B0aW9ucy5udW1iZXJQYXJzZU9wdGlvbnMpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOYW1lU3BhY2UodGFnbmFtZSkge1xuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KSB7XG4gICAgY29uc3QgdGFncyA9IHRhZ25hbWUuc3BsaXQoJzonKTtcbiAgICBjb25zdCBwcmVmaXggPSB0YWduYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgaWYgKHRhZ3NbMF0gPT09ICd4bWxucycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB0YWduYW1lID0gcHJlZml4ICsgdGFnc1sxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhZ25hbWU7XG59XG5cbi8vVE9ETzogY2hhbmdlIHJlZ2V4IHRvIGNhcHR1cmUgTlNcbi8vY29uc3QgYXR0cnNSZWd4ID0gbmV3IFJlZ0V4cChcIihbXFxcXHdcXFxcLVxcXFwuXFxcXDpdKylcXFxccyo9XFxcXHMqKFsnXFxcIl0pKCgufFxcbikqPylcXFxcMlwiLFwiZ21cIik7XG5jb25zdCBhdHRyc1JlZ3ggPSBuZXcgUmVnRXhwKCcoW15cXFxccz1dKylcXFxccyooPVxcXFxzKihbXFwnXCJdKShbXFxcXHNcXFxcU10qPylcXFxcMyk/JywgJ2dtJyk7XG5cbmZ1bmN0aW9uIGJ1aWxkQXR0cmlidXRlc01hcChhdHRyU3RyLCBqUGF0aCwgdGFnTmFtZSkge1xuICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMgIT09IHRydWUgJiYgdHlwZW9mIGF0dHJTdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYXR0clN0ciA9IGF0dHJTdHIucmVwbGFjZSgvXFxyP1xcbi9nLCAnICcpO1xuICAgIC8vYXR0clN0ciA9IGF0dHJTdHIgfHwgYXR0clN0ci50cmltKCk7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gZ2V0QWxsTWF0Y2hlcyhhdHRyU3RyLCBhdHRyc1JlZ3gpO1xuICAgIGNvbnN0IGxlbiA9IG1hdGNoZXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucmVzb2x2ZU5hbWVTcGFjZShtYXRjaGVzW2ldWzFdKTtcbiAgICAgIGlmICh0aGlzLmlnbm9yZUF0dHJpYnV0ZXNGbihhdHRyTmFtZSwgalBhdGgpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsZXQgb2xkVmFsID0gbWF0Y2hlc1tpXVs0XTtcbiAgICAgIGxldCBhTmFtZSA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lUHJlZml4ICsgYXR0ck5hbWU7XG4gICAgICBpZiAoYXR0ck5hbWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNmb3JtQXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgIGFOYW1lID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybUF0dHJpYnV0ZU5hbWUoYU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGFOYW1lID09PSBcIl9fcHJvdG9fX1wiKSBhTmFtZSAgPSBcIiNfX3Byb3RvX19cIjtcbiAgICAgICAgaWYgKG9sZFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmltVmFsdWVzKSB7XG4gICAgICAgICAgICBvbGRWYWwgPSBvbGRWYWwudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbGRWYWwgPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKG9sZFZhbCk7XG4gICAgICAgICAgY29uc3QgbmV3VmFsID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yKGF0dHJOYW1lLCBvbGRWYWwsIGpQYXRoKTtcbiAgICAgICAgICBpZihuZXdWYWwgPT09IG51bGwgfHwgbmV3VmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgLy9kb24ndCBwYXJzZVxuICAgICAgICAgICAgYXR0cnNbYU5hbWVdID0gb2xkVmFsO1xuICAgICAgICAgIH1lbHNlIGlmKHR5cGVvZiBuZXdWYWwgIT09IHR5cGVvZiBvbGRWYWwgfHwgbmV3VmFsICE9PSBvbGRWYWwpe1xuICAgICAgICAgICAgLy9vdmVyd3JpdGVcbiAgICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IG5ld1ZhbDtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vcGFyc2VcbiAgICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IHBhcnNlVmFsdWUoXG4gICAgICAgICAgICAgIG9sZFZhbCxcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhcnNlQXR0cmlidXRlVmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5udW1iZXJQYXJzZU9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cnNbYU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIU9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lKSB7XG4gICAgICBjb25zdCBhdHRyQ29sbGVjdGlvbiA9IHt9O1xuICAgICAgYXR0ckNvbGxlY3Rpb25bdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWVdID0gYXR0cnM7XG4gICAgICByZXR1cm4gYXR0ckNvbGxlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBhdHRyc1xuICB9XG59XG5cbmNvbnN0IHBhcnNlWG1sID0gZnVuY3Rpb24oeG1sRGF0YSkge1xuICB4bWxEYXRhID0geG1sRGF0YS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpOyAvL1RPRE86IHJlbW92ZSB0aGlzIGxpbmVcbiAgY29uc3QgeG1sT2JqID0gbmV3IHhtbE5vZGUoJyF4bWwnKTtcbiAgbGV0IGN1cnJlbnROb2RlID0geG1sT2JqO1xuICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICBsZXQgalBhdGggPSBcIlwiO1xuICBmb3IobGV0IGk9MDsgaTwgeG1sRGF0YS5sZW5ndGg7IGkrKyl7Ly9mb3IgZWFjaCBjaGFyIGluIFhNTCBkYXRhXG4gICAgY29uc3QgY2ggPSB4bWxEYXRhW2ldO1xuICAgIGlmKGNoID09PSAnPCcpe1xuICAgICAgLy8gY29uc3QgbmV4dEluZGV4ID0gaSsxO1xuICAgICAgLy8gY29uc3QgXzJuZENoYXIgPSB4bWxEYXRhW25leHRJbmRleF07XG4gICAgICBpZiggeG1sRGF0YVtpKzFdID09PSAnLycpIHsvL0Nsb3NpbmcgVGFnXG4gICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiPlwiLCBpLCBcIkNsb3NpbmcgVGFnIGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgIGxldCB0YWdOYW1lID0geG1sRGF0YS5zdWJzdHJpbmcoaSsyLGNsb3NlSW5kZXgpLnRyaW0oKTtcblxuICAgICAgICBpZih0aGlzLm9wdGlvbnMucmVtb3ZlTlNQcmVmaXgpe1xuICAgICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSB0YWdOYW1lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICAgIGlmKGNvbG9uSW5kZXggIT09IC0xKXtcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cihjb2xvbkluZGV4KzEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKSB7XG4gICAgICAgICAgdGFnTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY3VycmVudE5vZGUpe1xuICAgICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBpZiBsYXN0IHRhZyBvZiBuZXN0ZWQgdGFnIHdhcyB1bnBhaXJlZCB0YWdcbiAgICAgICAgY29uc3QgbGFzdFRhZ05hbWUgPSBqUGF0aC5zdWJzdHJpbmcoalBhdGgubGFzdEluZGV4T2YoXCIuXCIpKzEpO1xuICAgICAgICBpZih0YWdOYW1lICYmIHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEgKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucGFpcmVkIHRhZyBjYW4gbm90IGJlIHVzZWQgYXMgY2xvc2luZyB0YWc6IDwvJHt0YWdOYW1lfT5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvcEluZGV4ID0gMFxuICAgICAgICBpZihsYXN0VGFnTmFtZSAmJiB0aGlzLm9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YobGFzdFRhZ05hbWUpICE9PSAtMSApe1xuICAgICAgICAgIHByb3BJbmRleCA9IGpQYXRoLmxhc3RJbmRleE9mKCcuJywgalBhdGgubGFzdEluZGV4T2YoJy4nKS0xKVxuICAgICAgICAgIHRoaXMudGFnc05vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcHJvcEluZGV4ID0galBhdGgubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyaW5nKDAsIHByb3BJbmRleCk7XG5cbiAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLnRhZ3NOb2RlU3RhY2sucG9wKCk7Ly9hdm9pZCByZWN1cnNpb24sIHNldCB0aGUgcGFyZW50IHRhZyBzY29wZVxuICAgICAgICB0ZXh0RGF0YSA9IFwiXCI7XG4gICAgICAgIGkgPSBjbG9zZUluZGV4O1xuICAgICAgfSBlbHNlIGlmKCB4bWxEYXRhW2krMV0gPT09ICc/Jykge1xuXG4gICAgICAgIGxldCB0YWdEYXRhID0gcmVhZFRhZ0V4cCh4bWxEYXRhLGksIGZhbHNlLCBcIj8+XCIpO1xuICAgICAgICBpZighdGFnRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiUGkgVGFnIGlzIG5vdCBjbG9zZWQuXCIpO1xuXG4gICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuICAgICAgICBpZiggKHRoaXMub3B0aW9ucy5pZ25vcmVEZWNsYXJhdGlvbiAmJiB0YWdEYXRhLnRhZ05hbWUgPT09IFwiP3htbFwiKSB8fCB0aGlzLm9wdGlvbnMuaWdub3JlUGlUYWdzKXtcblxuICAgICAgICB9ZWxzZXtcbiAgXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnRGF0YS50YWdOYW1lKTtcbiAgICAgICAgICBjaGlsZE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIFwiXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKHRhZ0RhdGEudGFnTmFtZSAhPT0gdGFnRGF0YS50YWdFeHAgJiYgdGFnRGF0YS5hdHRyRXhwUHJlc2VudCl7XG4gICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0RhdGEudGFnRXhwLCBqUGF0aCwgdGFnRGF0YS50YWdOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aCwgaSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGkgPSB0YWdEYXRhLmNsb3NlSW5kZXggKyAxO1xuICAgICAgfSBlbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAzKSA9PT0gJyEtLScpIHtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiLS0+XCIsIGkrNCwgXCJDb21tZW50IGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUpe1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB4bWxEYXRhLnN1YnN0cmluZyhpICsgNCwgZW5kSW5kZXggLSAyKTtcblxuICAgICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuXG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUsIFsgeyBbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0gOiBjb21tZW50IH0gXSk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGVuZEluZGV4O1xuICAgICAgfSBlbHNlIGlmKCB4bWxEYXRhLnN1YnN0cihpICsgMSwgMikgPT09ICchRCcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZERvY1R5cGUoeG1sRGF0YSwgaSk7XG4gICAgICAgIHRoaXMuZG9jVHlwZUVudGl0aWVzID0gcmVzdWx0LmVudGl0aWVzO1xuICAgICAgICBpID0gcmVzdWx0Lmk7XG4gICAgICB9ZWxzZSBpZih4bWxEYXRhLnN1YnN0cihpICsgMSwgMikgPT09ICchWycpIHtcbiAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCJdXT5cIiwgaSwgXCJDREFUQSBpcyBub3QgY2xvc2VkLlwiKSAtIDI7XG4gICAgICAgIGNvbnN0IHRhZ0V4cCA9IHhtbERhdGEuc3Vic3RyaW5nKGkgKyA5LGNsb3NlSW5kZXgpO1xuXG4gICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnRXhwLCBjdXJyZW50Tm9kZS50YWduYW1lLCBqUGF0aCwgdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICBpZih2YWwgPT0gdW5kZWZpbmVkKSB2YWwgPSBcIlwiO1xuXG4gICAgICAgIC8vY2RhdGEgc2hvdWxkIGJlIHNldCBldmVuIGlmIGl0IGlzIDAgbGVuZ3RoIHN0cmluZ1xuICAgICAgICBpZih0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSl7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lLCBbIHsgW3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdIDogdGFnRXhwIH0gXSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGN1cnJlbnROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpID0gY2xvc2VJbmRleCArIDI7XG4gICAgICB9ZWxzZSB7Ly9PcGVuaW5nIHRhZ1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVhZFRhZ0V4cCh4bWxEYXRhLGksIHRoaXMub3B0aW9ucy5yZW1vdmVOU1ByZWZpeCk7XG4gICAgICAgIGxldCB0YWdOYW1lPSByZXN1bHQudGFnTmFtZTtcbiAgICAgICAgY29uc3QgcmF3VGFnTmFtZSA9IHJlc3VsdC5yYXdUYWdOYW1lO1xuICAgICAgICBsZXQgdGFnRXhwID0gcmVzdWx0LnRhZ0V4cDtcbiAgICAgICAgbGV0IGF0dHJFeHBQcmVzZW50ID0gcmVzdWx0LmF0dHJFeHBQcmVzZW50O1xuICAgICAgICBsZXQgY2xvc2VJbmRleCA9IHJlc3VsdC5jbG9zZUluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy9zYXZlIHRleHQgYXMgY2hpbGQgbm9kZVxuICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgdGV4dERhdGEpIHtcbiAgICAgICAgICBpZihjdXJyZW50Tm9kZS50YWduYW1lICE9PSAnIXhtbCcpe1xuICAgICAgICAgICAgLy93aGVuIG5lc3RlZCB0YWcgaXMgZm91bmRcbiAgICAgICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIGxhc3QgdGFnIHdhcyB1bnBhaXJlZCB0YWdcbiAgICAgICAgY29uc3QgbGFzdFRhZyA9IGN1cnJlbnROb2RlO1xuICAgICAgICBpZihsYXN0VGFnICYmIHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihsYXN0VGFnLnRhZ25hbWUpICE9PSAtMSApe1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyaW5nKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnTmFtZSAhPT0geG1sT2JqLnRhZ25hbWUpe1xuICAgICAgICAgIGpQYXRoICs9IGpQYXRoID8gXCIuXCIgKyB0YWdOYW1lIDogdGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgaWYgKHRoaXMuaXNJdFN0b3BOb2RlKHRoaXMub3B0aW9ucy5zdG9wTm9kZXMsIGpQYXRoLCB0YWdOYW1lKSkge1xuICAgICAgICAgIGxldCB0YWdDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAvL3NlbGYtY2xvc2luZyB0YWdcbiAgICAgICAgICBpZih0YWdFeHAubGVuZ3RoID4gMCAmJiB0YWdFeHAubGFzdEluZGV4T2YoXCIvXCIpID09PSB0YWdFeHAubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICBpZih0YWdOYW1lW3RhZ05hbWUubGVuZ3RoIC0gMV0gPT09IFwiL1wiKXsgLy9yZW1vdmUgdHJhaWxpbmcgJy8nXG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cigwLCB0YWdOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgdGFnRXhwID0gdGFnTmFtZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0YWdFeHAgPSB0YWdFeHAuc3Vic3RyKDAsIHRhZ0V4cC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSByZXN1bHQuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy91bnBhaXJlZCB0YWdcbiAgICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpID0gcmVzdWx0LmNsb3NlSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vbm9ybWFsIHRhZ1xuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAvL3JlYWQgdW50aWwgY2xvc2luZyB0YWcgaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZFN0b3BOb2RlRGF0YSh4bWxEYXRhLCByYXdUYWdOYW1lLCBjbG9zZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZighcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZW5kIG9mICR7cmF3VGFnTmFtZX1gKTtcbiAgICAgICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgICAgICAgIHRhZ0NvbnRlbnQgPSByZXN1bHQudGFnQ29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdOYW1lKTtcblxuICAgICAgICAgIGlmKHRhZ05hbWUgIT09IHRhZ0V4cCAmJiBhdHRyRXhwUHJlc2VudCl7XG4gICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0YWdDb250ZW50KSB7XG4gICAgICAgICAgICB0YWdDb250ZW50ID0gdGhpcy5wYXJzZVRleHREYXRhKHRhZ0NvbnRlbnQsIHRhZ05hbWUsIGpQYXRoLCB0cnVlLCBhdHRyRXhwUHJlc2VudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgICAgY2hpbGROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCB0YWdDb250ZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLmFkZENoaWxkKGN1cnJlbnROb2RlLCBjaGlsZE5vZGUsIGpQYXRoLCBzdGFydEluZGV4KTtcbiAgICAgICAgfWVsc2V7XG4gIC8vc2VsZkNsb3NpbmcgdGFnXG4gICAgICAgICAgaWYodGFnRXhwLmxlbmd0aCA+IDAgJiYgdGFnRXhwLmxhc3RJbmRleE9mKFwiL1wiKSA9PT0gdGFnRXhwLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgaWYodGFnTmFtZVt0YWdOYW1lLmxlbmd0aCAtIDFdID09PSBcIi9cIil7IC8vcmVtb3ZlIHRyYWlsaW5nICcvJ1xuICAgICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoMCwgdGFnTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHIoMCwgalBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHRhZ0V4cCA9IHRhZ05hbWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGFnRXhwID0gdGFnRXhwLnN1YnN0cigwLCB0YWdFeHAubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKSB7XG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnTmFtZSk7XG4gICAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aCwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICAgIH1cbiAgICAvL29wZW5pbmcgdGFnXG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5ldyB4bWxOb2RlKCB0YWdOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudGFnc05vZGVTdGFjay5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGFnTmFtZSAhPT0gdGFnRXhwICYmIGF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdFeHAsIGpQYXRoLCB0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHREYXRhID0gXCJcIjtcbiAgICAgICAgICBpID0gY2xvc2VJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgdGV4dERhdGEgKz0geG1sRGF0YVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHhtbE9iai5jaGlsZDtcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgsIHN0YXJ0SW5kZXgpe1xuICAvLyB1bnNldCBzdGFydEluZGV4IGlmIG5vdCByZXF1ZXN0ZWRcbiAgaWYgKCF0aGlzLm9wdGlvbnMuY2FwdHVyZU1ldGFEYXRhKSBzdGFydEluZGV4ID0gdW5kZWZpbmVkO1xuICBjb25zdCByZXN1bHQgPSB0aGlzLm9wdGlvbnMudXBkYXRlVGFnKGNoaWxkTm9kZS50YWduYW1lLCBqUGF0aCwgY2hpbGROb2RlW1wiOkBcIl0pXG4gIGlmKHJlc3VsdCA9PT0gZmFsc2Upe1xuICB9IGVsc2UgaWYodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIil7XG4gICAgY2hpbGROb2RlLnRhZ25hbWUgPSByZXN1bHRcbiAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUsIHN0YXJ0SW5kZXgpO1xuICB9ZWxzZXtcbiAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUsIHN0YXJ0SW5kZXgpO1xuICB9XG59XG5cbmNvbnN0IHJlcGxhY2VFbnRpdGllc1ZhbHVlID0gZnVuY3Rpb24odmFsKXtcblxuICBpZih0aGlzLm9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKXtcbiAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5kb2NUeXBlRW50aXRpZXMpe1xuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5kb2NUeXBlRW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ3gsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5sYXN0RW50aXRpZXMpe1xuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5sYXN0RW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ2V4LCBlbnRpdHkudmFsKTtcbiAgICB9XG4gICAgaWYodGhpcy5vcHRpb25zLmh0bWxFbnRpdGllcyl7XG4gICAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5odG1sRW50aXRpZXMpe1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmh0bWxFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoIGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbCA9IHZhbC5yZXBsYWNlKCB0aGlzLmFtcEVudGl0eS5yZWdleCwgdGhpcy5hbXBFbnRpdHkudmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoLCBpc0xlYWZOb2RlKSB7XG4gIGlmICh0ZXh0RGF0YSkgeyAvL3N0b3JlIHByZXZpb3VzbHkgY29sbGVjdGVkIGRhdGEgYXMgdGV4dE5vZGVcbiAgICBpZihpc0xlYWZOb2RlID09PSB1bmRlZmluZWQpIGlzTGVhZk5vZGUgPSBjdXJyZW50Tm9kZS5jaGlsZC5sZW5ndGggPT09IDBcbiAgICBcbiAgICB0ZXh0RGF0YSA9IHRoaXMucGFyc2VUZXh0RGF0YSh0ZXh0RGF0YSxcbiAgICAgIGN1cnJlbnROb2RlLnRhZ25hbWUsXG4gICAgICBqUGF0aCxcbiAgICAgIGZhbHNlLFxuICAgICAgY3VycmVudE5vZGVbXCI6QFwiXSA/IE9iamVjdC5rZXlzKGN1cnJlbnROb2RlW1wiOkBcIl0pLmxlbmd0aCAhPT0gMCA6IGZhbHNlLFxuICAgICAgaXNMZWFmTm9kZSk7XG5cbiAgICBpZiAodGV4dERhdGEgIT09IHVuZGVmaW5lZCAmJiB0ZXh0RGF0YSAhPT0gXCJcIilcbiAgICAgIGN1cnJlbnROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCB0ZXh0RGF0YSk7XG4gICAgdGV4dERhdGEgPSBcIlwiO1xuICB9XG4gIHJldHVybiB0ZXh0RGF0YTtcbn1cblxuLy9UT0RPOiB1c2UgalBhdGggdG8gc2ltcGxpZnkgdGhlIGxvZ2ljXG4vKipcbiAqIFxuICogQHBhcmFtIHtzdHJpbmdbXX0gc3RvcE5vZGVzIFxuICogQHBhcmFtIHtzdHJpbmd9IGpQYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFRhZ05hbWUgXG4gKi9cbmZ1bmN0aW9uIGlzSXRTdG9wTm9kZShzdG9wTm9kZXMsIGpQYXRoLCBjdXJyZW50VGFnTmFtZSl7XG4gIGNvbnN0IGFsbE5vZGVzRXhwID0gXCIqLlwiICsgY3VycmVudFRhZ05hbWU7XG4gIGZvciAoY29uc3Qgc3RvcE5vZGVQYXRoIGluIHN0b3BOb2Rlcykge1xuICAgIGNvbnN0IHN0b3BOb2RlRXhwID0gc3RvcE5vZGVzW3N0b3BOb2RlUGF0aF07XG4gICAgaWYoIGFsbE5vZGVzRXhwID09PSBzdG9wTm9kZUV4cCB8fCBqUGF0aCA9PT0gc3RvcE5vZGVFeHAgICkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRhZyBFeHByZXNzaW9uIGFuZCB3aGVyZSBpdCBpcyBlbmRpbmcgaGFuZGxpbmcgc2luZ2xlLWRvdWJsZSBxdW90ZXMgc2l0dWF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRGF0YSBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIHN0YXJ0aW5nIGluZGV4XG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gdGFnRXhwV2l0aENsb3NpbmdJbmRleCh4bWxEYXRhLCBpLCBjbG9zaW5nQ2hhciA9IFwiPlwiKXtcbiAgbGV0IGF0dHJCb3VuZGFyeTtcbiAgbGV0IHRhZ0V4cCA9IFwiXCI7XG4gIGZvciAobGV0IGluZGV4ID0gaTsgaW5kZXggPCB4bWxEYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBjaCA9IHhtbERhdGFbaW5kZXhdO1xuICAgIGlmIChhdHRyQm91bmRhcnkpIHtcbiAgICAgICAgaWYgKGNoID09PSBhdHRyQm91bmRhcnkpIGF0dHJCb3VuZGFyeSA9IFwiXCI7Ly9yZXNldFxuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgIGF0dHJCb3VuZGFyeSA9IGNoO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IGNsb3NpbmdDaGFyWzBdKSB7XG4gICAgICBpZihjbG9zaW5nQ2hhclsxXSl7XG4gICAgICAgIGlmKHhtbERhdGFbaW5kZXggKyAxXSA9PT0gY2xvc2luZ0NoYXJbMV0pe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0YWdFeHAsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHRhZ0V4cCxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXHQnKSB7XG4gICAgICBjaCA9IFwiIFwiXG4gICAgfVxuICAgIHRhZ0V4cCArPSBjaDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIHN0ciwgaSwgZXJyTXNnKXtcbiAgY29uc3QgY2xvc2luZ0luZGV4ID0geG1sRGF0YS5pbmRleE9mKHN0ciwgaSk7XG4gIGlmKGNsb3NpbmdJbmRleCA9PT0gLTEpe1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpXG4gIH1lbHNle1xuICAgIHJldHVybiBjbG9zaW5nSW5kZXggKyBzdHIubGVuZ3RoIC0gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkVGFnRXhwKHhtbERhdGEsaSwgcmVtb3ZlTlNQcmVmaXgsIGNsb3NpbmdDaGFyID0gXCI+XCIpe1xuICBjb25zdCByZXN1bHQgPSB0YWdFeHBXaXRoQ2xvc2luZ0luZGV4KHhtbERhdGEsIGkrMSwgY2xvc2luZ0NoYXIpO1xuICBpZighcmVzdWx0KSByZXR1cm47XG4gIGxldCB0YWdFeHAgPSByZXN1bHQuZGF0YTtcbiAgY29uc3QgY2xvc2VJbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSB0YWdFeHAuc2VhcmNoKC9cXHMvKTtcbiAgbGV0IHRhZ05hbWUgPSB0YWdFeHA7XG4gIGxldCBhdHRyRXhwUHJlc2VudCA9IHRydWU7XG4gIGlmKHNlcGFyYXRvckluZGV4ICE9PSAtMSl7Ly9zZXBhcmF0ZSB0YWcgbmFtZSBhbmQgYXR0cmlidXRlcyBleHByZXNzaW9uXG4gICAgdGFnTmFtZSA9IHRhZ0V4cC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpO1xuICAgIHRhZ0V4cCA9IHRhZ0V4cC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKS50cmltU3RhcnQoKTtcbiAgfVxuXG4gIGNvbnN0IHJhd1RhZ05hbWUgPSB0YWdOYW1lO1xuICBpZihyZW1vdmVOU1ByZWZpeCl7XG4gICAgY29uc3QgY29sb25JbmRleCA9IHRhZ05hbWUuaW5kZXhPZihcIjpcIik7XG4gICAgaWYoY29sb25JbmRleCAhPT0gLTEpe1xuICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKGNvbG9uSW5kZXgrMSk7XG4gICAgICBhdHRyRXhwUHJlc2VudCA9IHRhZ05hbWUgIT09IHJlc3VsdC5kYXRhLnN1YnN0cihjb2xvbkluZGV4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHRhZ0V4cDogdGFnRXhwLFxuICAgIGNsb3NlSW5kZXg6IGNsb3NlSW5kZXgsXG4gICAgYXR0ckV4cFByZXNlbnQ6IGF0dHJFeHBQcmVzZW50LFxuICAgIHJhd1RhZ05hbWU6IHJhd1RhZ05hbWUsXG4gIH1cbn1cbi8qKlxuICogZmluZCBwYWlyZWQgdGFnIGZvciBhIHN0b3Agbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGEgXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFxuICovXG5mdW5jdGlvbiByZWFkU3RvcE5vZGVEYXRhKHhtbERhdGEsIHRhZ05hbWUsIGkpe1xuICBjb25zdCBzdGFydEluZGV4ID0gaTtcbiAgLy8gU3RhcnRpbmcgYXQgMSBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgYW4gb3BlbiB0YWdcbiAgbGV0IG9wZW5UYWdDb3VudCA9IDE7XG5cbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYoIHhtbERhdGFbaV0gPT09IFwiPFwiKXsgXG4gICAgICBpZiAoeG1sRGF0YVtpKzFdID09PSBcIi9cIikgey8vY2xvc2UgdGFnXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCI+XCIsIGksIGAke3RhZ05hbWV9IGlzIG5vdCBjbG9zZWRgKTtcbiAgICAgICAgICBsZXQgY2xvc2VUYWdOYW1lID0geG1sRGF0YS5zdWJzdHJpbmcoaSsyLGNsb3NlSW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICBpZihjbG9zZVRhZ05hbWUgPT09IHRhZ05hbWUpe1xuICAgICAgICAgICAgb3BlblRhZ0NvdW50LS07XG4gICAgICAgICAgICBpZiAob3BlblRhZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFnQ29udGVudDogeG1sRGF0YS5zdWJzdHJpbmcoc3RhcnRJbmRleCwgaSksXG4gICAgICAgICAgICAgICAgaSA6IGNsb3NlSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZih4bWxEYXRhW2krMV0gPT09ICc/JykgeyBcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj8+XCIsIGkrMSwgXCJTdG9wTm9kZSBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAzKSA9PT0gJyEtLScpIHsgXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCItLT5cIiwgaSszLCBcIlN0b3BOb2RlIGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDIpID09PSAnIVsnKSB7IFxuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiXV0+XCIsIGksIFwiU3RvcE5vZGUgaXMgbm90IGNsb3NlZC5cIikgLSAyO1xuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YWdEYXRhID0gcmVhZFRhZ0V4cCh4bWxEYXRhLCBpLCAnPicpXG5cbiAgICAgICAgICBpZiAodGFnRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgb3BlblRhZ05hbWUgPSB0YWdEYXRhICYmIHRhZ0RhdGEudGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSA9PT0gdGFnTmFtZSAmJiB0YWdEYXRhLnRhZ0V4cFt0YWdEYXRhLnRhZ0V4cC5sZW5ndGgtMV0gIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWdDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaT10YWdEYXRhLmNsb3NlSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH0vL2VuZCBmb3IgbG9vcFxufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlKHZhbCwgc2hvdWxkUGFyc2UsIG9wdGlvbnMpIHtcbiAgaWYgKHNob3VsZFBhcnNlICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgLy9jb25zb2xlLmxvZyhvcHRpb25zKVxuICAgIGNvbnN0IG5ld3ZhbCA9IHZhbC50cmltKCk7XG4gICAgaWYobmV3dmFsID09PSAndHJ1ZScgKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIGlmKG5ld3ZhbCA9PT0gJ2ZhbHNlJyApIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIHJldHVybiB0b051bWJlcih2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0V4aXN0KHZhbCkpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZXRBbGxNYXRjaGVzIiwiaXNFeGlzdCIsInhtbE5vZGUiLCJyZWFkRG9jVHlwZSIsInRvTnVtYmVyIiwiZ2V0SWdub3JlQXR0cmlidXRlc0ZuIiwiT3JkZXJlZE9ialBhcnNlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImN1cnJlbnROb2RlIiwidGFnc05vZGVTdGFjayIsImRvY1R5cGVFbnRpdGllcyIsImxhc3RFbnRpdGllcyIsInJlZ2V4IiwidmFsIiwiYW1wRW50aXR5IiwiaHRtbEVudGl0aWVzIiwiXyIsInN0ciIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJOdW1iZXIiLCJwYXJzZUludCIsImFkZEV4dGVybmFsRW50aXRpZXMiLCJwYXJzZVhtbCIsInBhcnNlVGV4dERhdGEiLCJyZXNvbHZlTmFtZVNwYWNlIiwiYnVpbGRBdHRyaWJ1dGVzTWFwIiwiaXNJdFN0b3BOb2RlIiwicmVwbGFjZUVudGl0aWVzVmFsdWUiLCJyZWFkU3RvcE5vZGVEYXRhIiwic2F2ZVRleHRUb1BhcmVudFRhZyIsImFkZENoaWxkIiwiaWdub3JlQXR0cmlidXRlc0ZuIiwiaWdub3JlQXR0cmlidXRlcyIsImV4dGVybmFsRW50aXRpZXMiLCJlbnRLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJsZW5ndGgiLCJlbnQiLCJSZWdFeHAiLCJ0YWdOYW1lIiwialBhdGgiLCJkb250VHJpbSIsImhhc0F0dHJpYnV0ZXMiLCJpc0xlYWZOb2RlIiwiZXNjYXBlRW50aXRpZXMiLCJ1bmRlZmluZWQiLCJ0cmltVmFsdWVzIiwidHJpbSIsIm5ld3ZhbCIsInRhZ1ZhbHVlUHJvY2Vzc29yIiwicGFyc2VWYWx1ZSIsInBhcnNlVGFnVmFsdWUiLCJudW1iZXJQYXJzZU9wdGlvbnMiLCJ0cmltbWVkVmFsIiwidGFnbmFtZSIsInJlbW92ZU5TUHJlZml4IiwidGFncyIsInNwbGl0IiwicHJlZml4IiwiY2hhckF0IiwiYXR0cnNSZWd4IiwiYXR0clN0ciIsIm1hdGNoZXMiLCJsZW4iLCJhdHRycyIsImF0dHJOYW1lIiwib2xkVmFsIiwiYU5hbWUiLCJhdHRyaWJ1dGVOYW1lUHJlZml4IiwidHJhbnNmb3JtQXR0cmlidXRlTmFtZSIsIm5ld1ZhbCIsImF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yIiwicGFyc2VBdHRyaWJ1dGVWYWx1ZSIsImFsbG93Qm9vbGVhbkF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzR3JvdXBOYW1lIiwiYXR0ckNvbGxlY3Rpb24iLCJ4bWxEYXRhIiwicmVwbGFjZSIsInhtbE9iaiIsInRleHREYXRhIiwiY2giLCJjbG9zZUluZGV4IiwiZmluZENsb3NpbmdJbmRleCIsInN1YnN0cmluZyIsImNvbG9uSW5kZXgiLCJpbmRleE9mIiwic3Vic3RyIiwidHJhbnNmb3JtVGFnTmFtZSIsImxhc3RUYWdOYW1lIiwibGFzdEluZGV4T2YiLCJ1bnBhaXJlZFRhZ3MiLCJFcnJvciIsInByb3BJbmRleCIsInBvcCIsInRhZ0RhdGEiLCJyZWFkVGFnRXhwIiwiaWdub3JlRGVjbGFyYXRpb24iLCJpZ25vcmVQaVRhZ3MiLCJjaGlsZE5vZGUiLCJhZGQiLCJ0ZXh0Tm9kZU5hbWUiLCJ0YWdFeHAiLCJhdHRyRXhwUHJlc2VudCIsImVuZEluZGV4IiwiY29tbWVudFByb3BOYW1lIiwiY29tbWVudCIsInJlc3VsdCIsImVudGl0aWVzIiwiY2RhdGFQcm9wTmFtZSIsInJhd1RhZ05hbWUiLCJsYXN0VGFnIiwic3RhcnRJbmRleCIsInN0b3BOb2RlcyIsInRhZ0NvbnRlbnQiLCJwdXNoIiwiY2hpbGQiLCJjYXB0dXJlTWV0YURhdGEiLCJ1cGRhdGVUYWciLCJwcm9jZXNzRW50aXRpZXMiLCJlbnRpdHlOYW1lIiwiZW50aXR5IiwicmVneCIsImN1cnJlbnRUYWdOYW1lIiwiYWxsTm9kZXNFeHAiLCJzdG9wTm9kZVBhdGgiLCJzdG9wTm9kZUV4cCIsInRhZ0V4cFdpdGhDbG9zaW5nSW5kZXgiLCJjbG9zaW5nQ2hhciIsImF0dHJCb3VuZGFyeSIsImluZGV4IiwiZGF0YSIsImVyck1zZyIsImNsb3NpbmdJbmRleCIsInNlcGFyYXRvckluZGV4Iiwic2VhcmNoIiwidHJpbVN0YXJ0Iiwib3BlblRhZ0NvdW50IiwiY2xvc2VUYWdOYW1lIiwib3BlblRhZ05hbWUiLCJzaG91bGRQYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XMLParser)\n/* harmony export */ });\n/* harmony import */ var _OptionsBuilder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OptionsBuilder.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\");\n/* harmony import */ var _OrderedObjParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OrderedObjParser.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\");\n/* harmony import */ var _node2json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node2json.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js\");\n/* harmony import */ var _validator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../validator.js */ \"(rsc)/./node_modules/fast-xml-parser/src/validator.js\");\n/* harmony import */ var _xmlNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xmlNode.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\n\n\n\n\n\nclass XMLParser {\n    constructor(options){\n        this.externalEntities = {};\n        this.options = (0,_OptionsBuilder_js__WEBPACK_IMPORTED_MODULE_0__.buildOptions)(options);\n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */ parse(xmlData, validationOption) {\n        if (typeof xmlData === \"string\") {} else if (xmlData.toString) {\n            xmlData = xmlData.toString();\n        } else {\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\");\n        }\n        if (validationOption) {\n            if (validationOption === true) validationOption = {}; //validate with default options\n            const result = (0,_validator_js__WEBPACK_IMPORTED_MODULE_1__.validate)(xmlData, validationOption);\n            if (result !== true) {\n                throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n            }\n        }\n        const orderedObjParser = new _OrderedObjParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return (0,_node2json_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(orderedResult, this.options);\n    }\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */ addEntity(key, value) {\n        if (value.indexOf(\"&\") !== -1) {\n            throw new Error(\"Entity value can't have '&'\");\n        } else if (key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1) {\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n        } else if (value === \"&\") {\n            throw new Error(\"An entity with value '&' is not permitted\");\n        } else {\n            this.externalEntities[key] = value;\n        }\n    }\n    /**\n     * Returns a Symbol that can be used to access the metadata\n     * property on a node.\n     * \n     * If Symbol is not available in the environment, an ordinary property is used\n     * and the name of the property is here returned.\n     * \n     * The XMLMetaData property is only present when `captureMetaData`\n     * is true in the options.\n     */ static getMetaDataSymbol() {\n        return _xmlNode_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getMetaDataSymbol();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvWE1MUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrRDtBQUNHO0FBQ2Y7QUFDRztBQUNOO0FBRXBCLE1BQU1LO0lBRWpCQyxZQUFZQyxPQUFPLENBQUM7UUFDaEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxDQUFDO1FBQ3pCLElBQUksQ0FBQ0QsT0FBTyxHQUFHUCxnRUFBWUEsQ0FBQ087SUFFaEM7SUFDQTs7OztLQUlDLEdBQ0RFLE1BQU1DLE9BQU8sRUFBQ0MsZ0JBQWdCLEVBQUM7UUFDM0IsSUFBRyxPQUFPRCxZQUFZLFVBQVMsQ0FDL0IsT0FBTSxJQUFJQSxRQUFRRSxRQUFRLEVBQUM7WUFDdkJGLFVBQVVBLFFBQVFFLFFBQVE7UUFDOUIsT0FBSztZQUNELE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUlGLGtCQUFpQjtZQUNqQixJQUFHQSxxQkFBcUIsTUFBTUEsbUJBQW1CLENBQUMsR0FBRywrQkFBK0I7WUFFcEYsTUFBTUcsU0FBU1gsdURBQVFBLENBQUNPLFNBQVNDO1lBQ2pDLElBQUlHLFdBQVcsTUFBTTtnQkFDbkIsTUFBTUQsTUFBTyxDQUFDLEVBQUVDLE9BQU9DLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBRUYsT0FBT0MsR0FBRyxDQUFDRSxJQUFJLENBQUMsQ0FBQyxFQUFFSCxPQUFPQyxHQUFHLENBQUNHLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZFO1FBQ0Y7UUFDRixNQUFNQyxtQkFBbUIsSUFBSWxCLDREQUFnQkEsQ0FBQyxJQUFJLENBQUNNLE9BQU87UUFDMURZLGlCQUFpQkMsbUJBQW1CLENBQUMsSUFBSSxDQUFDWixnQkFBZ0I7UUFDMUQsTUFBTWEsZ0JBQWdCRixpQkFBaUJHLFFBQVEsQ0FBQ1o7UUFDaEQsSUFBRyxJQUFJLENBQUNILE9BQU8sQ0FBQ2dCLGFBQWEsSUFBSUYsa0JBQWtCRyxXQUFXLE9BQU9IO2FBQ2hFLE9BQU9uQix5REFBUUEsQ0FBQ21CLGVBQWUsSUFBSSxDQUFDZCxPQUFPO0lBQ3BEO0lBRUE7Ozs7S0FJQyxHQUNEa0IsVUFBVUMsR0FBRyxFQUFFQyxLQUFLLEVBQUM7UUFDakIsSUFBR0EsTUFBTUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFFO1lBQ3pCLE1BQU0sSUFBSWYsTUFBTTtRQUNwQixPQUFNLElBQUdhLElBQUlFLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBS0YsSUFBSUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFFO1lBQ3hELE1BQU0sSUFBSWYsTUFBTTtRQUNwQixPQUFNLElBQUdjLFVBQVUsS0FBSTtZQUNuQixNQUFNLElBQUlkLE1BQU07UUFDcEIsT0FBSztZQUNELElBQUksQ0FBQ0wsZ0JBQWdCLENBQUNrQixJQUFJLEdBQUdDO1FBQ2pDO0lBQ0o7SUFFQTs7Ozs7Ozs7O0tBU0MsR0FDRCxPQUFPRSxvQkFBb0I7UUFDdkIsT0FBT3pCLG1EQUFPQSxDQUFDeUIsaUJBQWlCO0lBQ3BDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydXJhbC1oZWFsdGgtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvWE1MUGFyc2VyLmpzPzM1NmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRPcHRpb25zfSBmcm9tICcuL09wdGlvbnNCdWlsZGVyLmpzJztcbmltcG9ydCBPcmRlcmVkT2JqUGFyc2VyIGZyb20gJy4vT3JkZXJlZE9ialBhcnNlci5qcyc7XG5pbXBvcnQgcHJldHRpZnkgZnJvbSAnLi9ub2RlMmpzb24uanMnO1xuaW1wb3J0IHt2YWxpZGF0ZX0gZnJvbSBcIi4uL3ZhbGlkYXRvci5qc1wiO1xuaW1wb3J0IFhtbE5vZGUgZnJvbSAnLi94bWxOb2RlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWE1MUGFyc2Vye1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmV4dGVybmFsRW50aXRpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYnVpbGRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgWE1MIGRhdHMgdG8gSlMgb2JqZWN0IFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0geG1sRGF0YSBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSB2YWxpZGF0aW9uT3B0aW9uIFxuICAgICAqL1xuICAgIHBhcnNlKHhtbERhdGEsdmFsaWRhdGlvbk9wdGlvbil7XG4gICAgICAgIGlmKHR5cGVvZiB4bWxEYXRhID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgfWVsc2UgaWYoIHhtbERhdGEudG9TdHJpbmcpe1xuICAgICAgICAgICAgeG1sRGF0YSA9IHhtbERhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYTUwgZGF0YSBpcyBhY2NlcHRlZCBpbiBTdHJpbmcgb3IgQnl0ZXNbXSBmb3JtLlwiKVxuICAgICAgICB9XG4gICAgICAgIGlmKCB2YWxpZGF0aW9uT3B0aW9uKXtcbiAgICAgICAgICAgIGlmKHZhbGlkYXRpb25PcHRpb24gPT09IHRydWUpIHZhbGlkYXRpb25PcHRpb24gPSB7fTsgLy92YWxpZGF0ZSB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh4bWxEYXRhLCB2YWxpZGF0aW9uT3B0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIGAke3Jlc3VsdC5lcnIubXNnfToke3Jlc3VsdC5lcnIubGluZX06JHtyZXN1bHQuZXJyLmNvbH1gIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yZGVyZWRPYmpQYXJzZXIgPSBuZXcgT3JkZXJlZE9ialBhcnNlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBvcmRlcmVkT2JqUGFyc2VyLmFkZEV4dGVybmFsRW50aXRpZXModGhpcy5leHRlcm5hbEVudGl0aWVzKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFJlc3VsdCA9IG9yZGVyZWRPYmpQYXJzZXIucGFyc2VYbWwoeG1sRGF0YSk7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZU9yZGVyIHx8IG9yZGVyZWRSZXN1bHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9yZGVyZWRSZXN1bHQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIHByZXR0aWZ5KG9yZGVyZWRSZXN1bHQsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIEVudGl0eSB3aGljaCBpcyBub3QgYnkgZGVmYXVsdCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG4gICAgICovXG4gICAgYWRkRW50aXR5KGtleSwgdmFsdWUpe1xuICAgICAgICBpZih2YWx1ZS5pbmRleE9mKFwiJlwiKSAhPT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50aXR5IHZhbHVlIGNhbid0IGhhdmUgJyYnXCIpXG4gICAgICAgIH1lbHNlIGlmKGtleS5pbmRleE9mKFwiJlwiKSAhPT0gLTEgfHwga2V5LmluZGV4T2YoXCI7XCIpICE9PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBlbnRpdHkgbXVzdCBiZSBzZXQgd2l0aG91dCAnJicgYW5kICc7Jy4gRWcuIHVzZSAnI3hEJyBmb3IgJyYjeEQ7J1wiKVxuICAgICAgICB9ZWxzZSBpZih2YWx1ZSA9PT0gXCImXCIpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZW50aXR5IHdpdGggdmFsdWUgJyYnIGlzIG5vdCBwZXJtaXR0ZWRcIik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5leHRlcm5hbEVudGl0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTeW1ib2wgdGhhdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlIG1ldGFkYXRhXG4gICAgICogcHJvcGVydHkgb24gYSBub2RlLlxuICAgICAqIFxuICAgICAqIElmIFN5bWJvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBlbnZpcm9ubWVudCwgYW4gb3JkaW5hcnkgcHJvcGVydHkgaXMgdXNlZFxuICAgICAqIGFuZCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaXMgaGVyZSByZXR1cm5lZC5cbiAgICAgKiBcbiAgICAgKiBUaGUgWE1MTWV0YURhdGEgcHJvcGVydHkgaXMgb25seSBwcmVzZW50IHdoZW4gYGNhcHR1cmVNZXRhRGF0YWBcbiAgICAgKiBpcyB0cnVlIGluIHRoZSBvcHRpb25zLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNZXRhRGF0YVN5bWJvbCgpIHtcbiAgICAgICAgcmV0dXJuIFhtbE5vZGUuZ2V0TWV0YURhdGFTeW1ib2woKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiYnVpbGRPcHRpb25zIiwiT3JkZXJlZE9ialBhcnNlciIsInByZXR0aWZ5IiwidmFsaWRhdGUiLCJYbWxOb2RlIiwiWE1MUGFyc2VyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiZXh0ZXJuYWxFbnRpdGllcyIsInBhcnNlIiwieG1sRGF0YSIsInZhbGlkYXRpb25PcHRpb24iLCJ0b1N0cmluZyIsIkVycm9yIiwicmVzdWx0IiwiZXJyIiwibXNnIiwibGluZSIsImNvbCIsIm9yZGVyZWRPYmpQYXJzZXIiLCJhZGRFeHRlcm5hbEVudGl0aWVzIiwib3JkZXJlZFJlc3VsdCIsInBhcnNlWG1sIiwicHJlc2VydmVPcmRlciIsInVuZGVmaW5lZCIsImFkZEVudGl0eSIsImtleSIsInZhbHVlIiwiaW5kZXhPZiIsImdldE1ldGFEYXRhU3ltYm9sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ prettify)\n/* harmony export */ });\n/* harmony import */ var _xmlNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xmlNode.js */ \"(rsc)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\n\n\nconst METADATA_SYMBOL = _xmlNode_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMetaDataSymbol();\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */ function prettify(node, options) {\n    return compress(node, options);\n}\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */ function compress(arr, options, jPath) {\n    let text;\n    const compressedObj = {};\n    for(let i = 0; i < arr.length; i++){\n        const tagObj = arr[i];\n        const property = propName(tagObj);\n        let newJpath = \"\";\n        if (jPath === undefined) newJpath = property;\n        else newJpath = jPath + \".\" + property;\n        if (property === options.textNodeName) {\n            if (text === undefined) text = tagObj[property];\n            else text += \"\" + tagObj[property];\n        } else if (property === undefined) {\n            continue;\n        } else if (tagObj[property]) {\n            let val = compress(tagObj[property], options, newJpath);\n            const isLeaf = isLeafTag(val, options);\n            if (tagObj[METADATA_SYMBOL] !== undefined) {\n                val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL]; // copy over metadata\n            }\n            if (tagObj[\":@\"]) {\n                assignAttributes(val, tagObj[\":@\"], newJpath, options);\n            } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {\n                val = val[options.textNodeName];\n            } else if (Object.keys(val).length === 0) {\n                if (options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n                else val = \"\";\n            }\n            if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n                if (!Array.isArray(compressedObj[property])) {\n                    compressedObj[property] = [\n                        compressedObj[property]\n                    ];\n                }\n                compressedObj[property].push(val);\n            } else {\n                //TODO: if a node is not an array, then check if it should be an array\n                //also determine if it is a leaf node\n                if (options.isArray(property, newJpath, isLeaf)) {\n                    compressedObj[property] = [\n                        val\n                    ];\n                } else {\n                    compressedObj[property] = val;\n                }\n            }\n        }\n    }\n    // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n    if (typeof text === \"string\") {\n        if (text.length > 0) compressedObj[options.textNodeName] = text;\n    } else if (text !== undefined) compressedObj[options.textNodeName] = text;\n    return compressedObj;\n}\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\nfunction assignAttributes(obj, attrMap, jpath, options) {\n    if (attrMap) {\n        const keys = Object.keys(attrMap);\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            const atrrName = keys[i];\n            if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n                obj[atrrName] = [\n                    attrMap[atrrName]\n                ];\n            } else {\n                obj[atrrName] = attrMap[atrrName];\n            }\n        }\n    }\n}\nfunction isLeafTag(obj, options) {\n    const { textNodeName } = options;\n    const propCount = Object.keys(obj).length;\n    if (propCount === 0) {\n        return true;\n    }\n    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)) {\n        return true;\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvbm9kZTJqc29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFbUM7QUFFbkMsTUFBTUMsa0JBQWtCRCxtREFBT0EsQ0FBQ0UsaUJBQWlCO0FBRWpEOzs7OztDQUtDLEdBQ2MsU0FBU0MsU0FBU0MsSUFBSSxFQUFFQyxPQUFPO0lBQzVDLE9BQU9DLFNBQVVGLE1BQU1DO0FBQ3pCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsU0FBU0MsR0FBRyxFQUFFRixPQUFPLEVBQUVHLEtBQUs7SUFDbkMsSUFBSUM7SUFDSixNQUFNQyxnQkFBZ0IsQ0FBQztJQUN2QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosSUFBSUssTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1FLFNBQVNOLEdBQUcsQ0FBQ0ksRUFBRTtRQUNyQixNQUFNRyxXQUFXQyxTQUFTRjtRQUMxQixJQUFJRyxXQUFXO1FBQ2YsSUFBR1IsVUFBVVMsV0FBV0QsV0FBV0Y7YUFDOUJFLFdBQVdSLFFBQVEsTUFBTU07UUFFOUIsSUFBR0EsYUFBYVQsUUFBUWEsWUFBWSxFQUFDO1lBQ25DLElBQUdULFNBQVNRLFdBQVdSLE9BQU9JLE1BQU0sQ0FBQ0MsU0FBUztpQkFDekNMLFFBQVEsS0FBS0ksTUFBTSxDQUFDQyxTQUFTO1FBQ3BDLE9BQU0sSUFBR0EsYUFBYUcsV0FBVTtZQUM5QjtRQUNGLE9BQU0sSUFBR0osTUFBTSxDQUFDQyxTQUFTLEVBQUM7WUFFeEIsSUFBSUssTUFBTWIsU0FBU08sTUFBTSxDQUFDQyxTQUFTLEVBQUVULFNBQVNXO1lBQzlDLE1BQU1JLFNBQVNDLFVBQVVGLEtBQUtkO1lBQzlCLElBQUlRLE1BQU0sQ0FBQ1osZ0JBQWdCLEtBQUtnQixXQUFXO2dCQUN6Q0UsR0FBRyxDQUFDbEIsZ0JBQWdCLEdBQUdZLE1BQU0sQ0FBQ1osZ0JBQWdCLEVBQUUscUJBQXFCO1lBQ3ZFO1lBRUEsSUFBR1ks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Q0FBQ1osYUFBYSxLQUFLLGFBQWFZLEdBQUcsQ0FBQ1osYUFBYSxLQUFLLElBQ3RGO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnVyYWwtaGVhbHRoLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL25vZGUyanNvbi5qcz9kZmNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFhtbE5vZGUgZnJvbSAnLi94bWxOb2RlLmpzJztcblxuY29uc3QgTUVUQURBVEFfU1lNQk9MID0gWG1sTm9kZS5nZXRNZXRhRGF0YVN5bWJvbCgpO1xuXG4vKipcbiAqIFxuICogQHBhcmFtIHthcnJheX0gbm9kZSBcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXR0aWZ5KG5vZGUsIG9wdGlvbnMpe1xuICByZXR1cm4gY29tcHJlc3MoIG5vZGUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFxuICogQHBhcmFtIHthcnJheX0gYXJyIFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGggXG4gKiBAcmV0dXJucyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3MoYXJyLCBvcHRpb25zLCBqUGF0aCl7XG4gIGxldCB0ZXh0O1xuICBjb25zdCBjb21wcmVzc2VkT2JqID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGFnT2JqID0gYXJyW2ldO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcE5hbWUodGFnT2JqKTtcbiAgICBsZXQgbmV3SnBhdGggPSBcIlwiO1xuICAgIGlmKGpQYXRoID09PSB1bmRlZmluZWQpIG5ld0pwYXRoID0gcHJvcGVydHk7XG4gICAgZWxzZSBuZXdKcGF0aCA9IGpQYXRoICsgXCIuXCIgKyBwcm9wZXJ0eTtcblxuICAgIGlmKHByb3BlcnR5ID09PSBvcHRpb25zLnRleHROb2RlTmFtZSl7XG4gICAgICBpZih0ZXh0ID09PSB1bmRlZmluZWQpIHRleHQgPSB0YWdPYmpbcHJvcGVydHldO1xuICAgICAgZWxzZSB0ZXh0ICs9IFwiXCIgKyB0YWdPYmpbcHJvcGVydHldO1xuICAgIH1lbHNlIGlmKHByb3BlcnR5ID09PSB1bmRlZmluZWQpe1xuICAgICAgY29udGludWU7XG4gICAgfWVsc2UgaWYodGFnT2JqW3Byb3BlcnR5XSl7XG4gICAgICBcbiAgICAgIGxldCB2YWwgPSBjb21wcmVzcyh0YWdPYmpbcHJvcGVydHldLCBvcHRpb25zLCBuZXdKcGF0aCk7XG4gICAgICBjb25zdCBpc0xlYWYgPSBpc0xlYWZUYWcodmFsLCBvcHRpb25zKTtcbiAgICAgIGlmICh0YWdPYmpbTUVUQURBVEFfU1lNQk9MXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbFtNRVRBREFUQV9TWU1CT0xdID0gdGFnT2JqW01FVEFEQVRBX1NZTUJPTF07IC8vIGNvcHkgb3ZlciBtZXRhZGF0YVxuICAgICAgfVxuXG4gICAgICBpZih0YWdPYmpbXCI6QFwiXSl7XG4gICAgICAgIGFzc2lnbkF0dHJpYnV0ZXMoIHZhbCwgdGFnT2JqW1wiOkBcIl0sIG5ld0pwYXRoLCBvcHRpb25zKTtcbiAgICAgIH1lbHNlIGlmKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAxICYmIHZhbFtvcHRpb25zLnRleHROb2RlTmFtZV0gIT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5hbHdheXNDcmVhdGVUZXh0Tm9kZSl7XG4gICAgICAgIHZhbCA9IHZhbFtvcHRpb25zLnRleHROb2RlTmFtZV07XG4gICAgICB9ZWxzZSBpZihPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGlmKG9wdGlvbnMuYWx3YXlzQ3JlYXRlVGV4dE5vZGUpIHZhbFtvcHRpb25zLnRleHROb2RlTmFtZV0gPSBcIlwiO1xuICAgICAgICBlbHNlIHZhbCA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbXByZXNzZWRPYmpbcHJvcGVydHldICE9PSB1bmRlZmluZWQgJiYgY29tcHJlc3NlZE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkoY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSA9IFsgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gXTtcbiAgICAgICAgfVxuICAgICAgICBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XS5wdXNoKHZhbCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy9UT0RPOiBpZiBhIG5vZGUgaXMgbm90IGFuIGFycmF5LCB0aGVuIGNoZWNrIGlmIGl0IHNob3VsZCBiZSBhbiBhcnJheVxuICAgICAgICAvL2Fsc28gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgbGVhZiBub2RlXG4gICAgICAgIGlmIChvcHRpb25zLmlzQXJyYXkocHJvcGVydHksIG5ld0pwYXRoLCBpc0xlYWYgKSkge1xuICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gW3ZhbF07XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICB9XG4gIC8vIGlmKHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSBjb21wcmVzc2VkT2JqW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IHRleHQ7XG4gIGlmKHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiKXtcbiAgICBpZih0ZXh0Lmxlbmd0aCA+IDApIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgfWVsc2UgaWYodGV4dCAhPT0gdW5kZWZpbmVkKSBjb21wcmVzc2VkT2JqW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IHRleHQ7XG4gIHJldHVybiBjb21wcmVzc2VkT2JqO1xufVxuXG5mdW5jdGlvbiBwcm9wTmFtZShvYmope1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZihrZXkgIT09IFwiOkBcIikgcmV0dXJuIGtleTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVzKG9iaiwgYXR0ck1hcCwganBhdGgsIG9wdGlvbnMpe1xuICBpZiAoYXR0ck1hcCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyTWFwKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDsgLy9kb24ndCBtYWtlIGl0IGlubGluZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0cnJOYW1lID0ga2V5c1tpXTtcbiAgICAgIGlmIChvcHRpb25zLmlzQXJyYXkoYXRyck5hbWUsIGpwYXRoICsgXCIuXCIgKyBhdHJyTmFtZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgb2JqW2F0cnJOYW1lXSA9IFsgYXR0ck1hcFthdHJyTmFtZV0gXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialthdHJyTmFtZV0gPSBhdHRyTWFwW2F0cnJOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMZWFmVGFnKG9iaiwgb3B0aW9ucyl7XG4gIGNvbnN0IHsgdGV4dE5vZGVOYW1lIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcm9wQ291bnQgPSBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbiAgXG4gIGlmIChwcm9wQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICBwcm9wQ291bnQgPT09IDEgJiZcbiAgICAob2JqW3RleHROb2RlTmFtZV0gfHwgdHlwZW9mIG9ialt0ZXh0Tm9kZU5hbWVdID09PSBcImJvb2xlYW5cIiB8fCBvYmpbdGV4dE5vZGVOYW1lXSA9PT0gMClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsiWG1sTm9kZSIsIk1FVEFEQVRBX1NZTUJPTCIsImdldE1ldGFEYXRhU3ltYm9sIiwicHJldHRpZnkiLCJub2RlIiwib3B0aW9ucyIsImNvbXByZXNzIiwiYXJyIiwialBhdGgiLCJ0ZXh0IiwiY29tcHJlc3NlZE9iaiIsImkiLCJsZW5ndGgiLCJ0YWdPYmoiLCJwcm9wZXJ0eSIsInByb3BOYW1lIiwibmV3SnBhdGgiLCJ1bmRlZmluZWQiLCJ0ZXh0Tm9kZU5hbWUiLCJ2YWwiLCJpc0xlYWYiLCJpc0xlYWZUYWciLCJhc3NpZ25BdHRyaWJ1dGVzIiwiT2JqZWN0Iiwia2V5cyIsImFsd2F5c0NyZWF0ZVRleHROb2RlIiwiaGFzT3duUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwib2JqIiwia2V5IiwiYXR0ck1hcCIsImpwYXRoIiwibGVuIiwiYXRyck5hbWUiLCJwcm9wQ291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XmlNode)\n/* harmony export */ });\n\nlet METADATA_SYMBOL;\nif (typeof Symbol !== \"function\") {\n    METADATA_SYMBOL = \"@@xmlMetadata\";\n} else {\n    METADATA_SYMBOL = Symbol(\"XML Node Metadata\");\n}\nclass XmlNode {\n    constructor(tagname){\n        this.tagname = tagname;\n        this.child = []; //nested tags, text, cdata, comments in order\n        this[\":@\"] = {}; //attributes map\n    }\n    add(key, val) {\n        // this.child.push( {name : key, val: val, isCdata: isCdata });\n        if (key === \"__proto__\") key = \"#__proto__\";\n        this.child.push({\n            [key]: val\n        });\n    }\n    addChild(node, startIndex) {\n        if (node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n        if (node[\":@\"] && Object.keys(node[\":@\"]).length > 0) {\n            this.child.push({\n                [node.tagname]: node.child,\n                [\":@\"]: node[\":@\"]\n            });\n        } else {\n            this.child.push({\n                [node.tagname]: node.child\n            });\n        }\n        // if requested, add the startIndex\n        if (startIndex !== undefined) {\n            // Note: for now we just overwrite the metadata. If we had more complex metadata,\n            // we might need to do an object append here:  metadata = { ...metadata, startIndex }\n            this.child[this.child.length - 1][METADATA_SYMBOL] = {\n                startIndex\n            };\n        }\n    }\n    /** symbol used for metadata */ static getMetaDataSymbol() {\n        return METADATA_SYMBOL;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIveG1sTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFFQSxJQUFJQTtBQUVKLElBQUksT0FBT0MsV0FBVyxZQUFZO0lBQ2hDRCxrQkFBa0I7QUFDcEIsT0FBTztJQUNMQSxrQkFBa0JDLE9BQU87QUFDM0I7QUFFZSxNQUFNQztJQUNuQkMsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUUsRUFBRSw2Q0FBNkM7UUFDOUQsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsZ0JBQWdCO0lBQ25DO0lBQ0FDLElBQUlDLEdBQUcsRUFBQ0MsR0FBRyxFQUFDO1FBQ1YsK0RBQStEO1FBQy9ELElBQUdELFFBQVEsYUFBYUEsTUFBTTtRQUM5QixJQUFJLENBQUNGLEtBQUssQ0FBQ0ksSUFBSSxDQUFFO1lBQUMsQ0FBQ0YsSUFBSSxFQUFFQztRQUFJO0lBQy9CO0lBQ0FFLFNBQVNDLElBQUksRUFBRUMsVUFBVSxFQUFFO1FBQ3pCLElBQUdELEtBQUtQLE9BQU8sS0FBSyxhQUFhTyxLQUFLUCxPQUFPLEdBQUc7UUFDaEQsSUFBR08sSUFBSSxDQUFDLEtBQUssSUFBSUUsT0FBT0MsSUFBSSxDQUFDSCxJQUFJLENBQUMsS0FBSyxFQUFFSSxNQUFNLEdBQUcsR0FBRTtZQUNsRCxJQUFJLENBQUNWLEtBQUssQ0FBQ0ksSUFBSSxDQUFFO2dCQUFFLENBQUNFLEtBQUtQLE9BQU8sQ0FBQyxFQUFFTyxLQUFLTixLQUFLO2dCQUFFLENBQUMsS0FBSyxFQUFFTSxJQUFJLENBQUMsS0FBSztZQUFDO1FBQ3BFLE9BQUs7WUFDSCxJQUFJLENBQUNOLEtBQUssQ0FBQ0ksSUFBSSxDQUFFO2dCQUFFLENBQUNFLEtBQUtQLE9BQU8sQ0FBQyxFQUFFTyxLQUFLTixLQUFLO1lBQUM7UUFDaEQ7UUFDQSxtQ0FBbUM7UUFDbkMsSUFBSU8sZUFBZUksV0FBVztZQUM1QixpRkFBaUY7WUFDakYscUZBQXFGO1lBQ3JGLElBQUksQ0FBQ1gsS0FBSyxDQUFDLElBQUksQ0FBQ0EsS0FBSyxDQUFDVSxNQUFNLEdBQUcsRUFBRSxDQUFDZixnQkFBZ0IsR0FBRztnQkFBRVk7WUFBVztRQUNwRTtJQUNGO0lBQ0EsNkJBQTZCLEdBQzdCLE9BQU9LLG9CQUFvQjtRQUN6QixPQUFPakI7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnVyYWwtaGVhbHRoLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL3htbE5vZGUuanM/YjU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmxldCBNRVRBREFUQV9TWU1CT0w7XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgTUVUQURBVEFfU1lNQk9MID0gXCJAQHhtbE1ldGFkYXRhXCI7XG59IGVsc2Uge1xuICBNRVRBREFUQV9TWU1CT0wgPSBTeW1ib2woXCJYTUwgTm9kZSBNZXRhZGF0YVwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWG1sTm9kZXtcbiAgY29uc3RydWN0b3IodGFnbmFtZSkge1xuICAgIHRoaXMudGFnbmFtZSA9IHRhZ25hbWU7XG4gICAgdGhpcy5jaGlsZCA9IFtdOyAvL25lc3RlZCB0YWdzLCB0ZXh0LCBjZGF0YSwgY29tbWVudHMgaW4gb3JkZXJcbiAgICB0aGlzW1wiOkBcIl0gPSB7fTsgLy9hdHRyaWJ1dGVzIG1hcFxuICB9XG4gIGFkZChrZXksdmFsKXtcbiAgICAvLyB0aGlzLmNoaWxkLnB1c2goIHtuYW1lIDoga2V5LCB2YWw6IHZhbCwgaXNDZGF0YTogaXNDZGF0YSB9KTtcbiAgICBpZihrZXkgPT09IFwiX19wcm90b19fXCIpIGtleSA9IFwiI19fcHJvdG9fX1wiO1xuICAgIHRoaXMuY2hpbGQucHVzaCgge1trZXldOiB2YWwgfSk7XG4gIH1cbiAgYWRkQ2hpbGQobm9kZSwgc3RhcnRJbmRleCkge1xuICAgIGlmKG5vZGUudGFnbmFtZSA9PT0gXCJfX3Byb3RvX19cIikgbm9kZS50YWduYW1lID0gXCIjX19wcm90b19fXCI7XG4gICAgaWYobm9kZVtcIjpAXCJdICYmIE9iamVjdC5rZXlzKG5vZGVbXCI6QFwiXSkubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLmNoaWxkLnB1c2goIHsgW25vZGUudGFnbmFtZV06IG5vZGUuY2hpbGQsIFtcIjpAXCJdOiBub2RlW1wiOkBcIl0gfSk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLmNoaWxkLnB1c2goIHsgW25vZGUudGFnbmFtZV06IG5vZGUuY2hpbGQgfSk7XG4gICAgfVxuICAgIC8vIGlmIHJlcXVlc3RlZCwgYWRkIHRoZSBzdGFydEluZGV4XG4gICAgaWYgKHN0YXJ0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm90ZTogZm9yIG5vdyB3ZSBqdXN0IG92ZXJ3cml0ZSB0aGUgbWV0YWRhdGEuIElmIHdlIGhhZCBtb3JlIGNvbXBsZXggbWV0YWRhdGEsXG4gICAgICAvLyB3ZSBtaWdodCBuZWVkIHRvIGRvIGFuIG9iamVjdCBhcHBlbmQgaGVyZTogIG1ldGFkYXRhID0geyAuLi5tZXRhZGF0YSwgc3RhcnRJbmRleCB9XG4gICAgICB0aGlzLmNoaWxkW3RoaXMuY2hpbGQubGVuZ3RoIC0gMV1bTUVUQURBVEFfU1lNQk9MXSA9IHsgc3RhcnRJbmRleCB9O1xuICAgIH1cbiAgfVxuICAvKiogc3ltYm9sIHVzZWQgZm9yIG1ldGFkYXRhICovXG4gIHN0YXRpYyBnZXRNZXRhRGF0YVN5bWJvbCgpIHtcbiAgICByZXR1cm4gTUVUQURBVEFfU1lNQk9MO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTUVUQURBVEFfU1lNQk9MIiwiU3ltYm9sIiwiWG1sTm9kZSIsImNvbnN0cnVjdG9yIiwidGFnbmFtZSIsImNoaWxkIiwiYWRkIiwia2V5IiwidmFsIiwicHVzaCIsImFkZENoaWxkIiwibm9kZSIsInN0YXJ0SW5kZXgiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZ2V0TWV0YURhdGFTeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\n");

/***/ })

};
;